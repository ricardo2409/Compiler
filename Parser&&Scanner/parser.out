Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOLEAN

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID add_global_function SEMICOLON goto_main vars function main endProgram
Rule 2     endProgram -> <empty>
Rule 3     add_global_function -> <empty>
Rule 4     main -> INTTYPE MAIN change_to_global LPAREN RPAREN add_jump_to_main block
Rule 5     change_to_global -> <empty>
Rule 6     goto_main -> <empty>
Rule 7     add_jump_to_main -> <empty>
Rule 8     block -> LBRACE blockprima RBRACE
Rule 9     blockprima -> statute blockprima
Rule 10    blockprima -> empty
Rule 11    statute -> assignment
Rule 12    statute -> condition
Rule 13    statute -> write
Rule 14    statute -> read
Rule 15    statute -> cycle
Rule 16    statute -> functioncall SEMICOLON
Rule 17    statute -> return
Rule 18    condition -> IF LPAREN sexpression RPAREN do_condition_operation block else
Rule 19    do_condition_operation -> <empty>
Rule 20    else -> ELSE do_else_operation block
Rule 21    else -> empty
Rule 22    do_else_operation -> <empty>
Rule 23    vars -> VAR type ID array_declaration store_variable SEMICOLON vars
Rule 24    vars -> empty
Rule 25    store_variable -> <empty>
Rule 26    array_declaration -> LBRACKET dimen_variable sexpression calculate_dimen RBRACKET
Rule 27    array_declaration -> empty
Rule 28    dimen_variable -> <empty>
Rule 29    calculate_dimen -> <empty>
Rule 30    type -> INTTYPE
Rule 31    type -> FLOATTYPE
Rule 32    type -> STRINGTYPE
Rule 33    type -> BOOLTYPE
Rule 34    assignment -> ID push_id_operand array ASSIGN push_operator sexpression SEMICOLON
Rule 35    push_id_operand -> <empty>
Rule 36    push_operator -> <empty>
Rule 37    sexpression -> negation expression do_not_operation
Rule 38    negation -> NOT push_operator
Rule 39    negation -> empty
Rule 40    do_not_operation -> <empty>
Rule 41    expression -> expression relationaloperators push_operator exp do_relational_operation
Rule 42    expression -> exp
Rule 43    relationaloperators -> LESS
Rule 44    relationaloperators -> GREATER
Rule 45    relationaloperators -> EQUAL
Rule 46    relationaloperators -> NOTEQUAL
Rule 47    relationaloperators -> LESSOREQUAL
Rule 48    relationaloperators -> GREATEROREQUAL
Rule 49    relationaloperators -> AND
Rule 50    relationaloperators -> OR
Rule 51    do_relational_operation -> <empty>
Rule 52    exp -> exp mathoperators1 push_operator term do_math_operation1
Rule 53    exp -> term
Rule 54    mathoperators1 -> PLUS
Rule 55    mathoperators1 -> MINUS
Rule 56    do_math_operation1 -> <empty>
Rule 57    term -> term mathoperators2 push_operator factor do_math_operation2
Rule 58    term -> factor
Rule 59    mathoperators2 -> TIMES
Rule 60    mathoperators2 -> DIVIDE
Rule 61    do_math_operation2 -> <empty>
Rule 62    factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom
Rule 63    factor -> varConst
Rule 64    push_false_bottom -> <empty>
Rule 65    pop_false_bottom -> <empty>
Rule 66    varConst -> ID push_id_operand array
Rule 67    varConst -> FLOAT push_float_operand
Rule 68    varConst -> INT push_int_operand
Rule 69    varConst -> bool push_bool_operand
Rule 70    varConst -> STRING push_string_operand
Rule 71    varConst -> functioncall
Rule 72    array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET
Rule 73    array -> empty
Rule 74    validate_index -> <empty>
Rule 75    access_dimen_var -> <empty>
Rule 76    bool -> TRUE
Rule 77    bool -> FALSE
Rule 78    push_float_operand -> <empty>
Rule 79    push_int_operand -> <empty>
Rule 80    push_bool_operand -> <empty>
Rule 81    push_string_operand -> <empty>
Rule 82    functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments
Rule 83    check_function_existance -> <empty>
Rule 84    generate_era -> <empty>
Rule 85    validate_arguments -> <empty>
Rule 86    funcargum -> sexpression store_argument funcargumprima
Rule 87    funcargum -> empty
Rule 88    funcargumprima -> COMMA sexpression store_argument funcargumprima
Rule 89    funcargumprima -> empty
Rule 90    store_argument -> <empty>
Rule 91    function -> FUNCTION functiontype ID store_function LPAREN parameter RPAREN vars add_func_quad_start block end_process function
Rule 92    function -> empty
Rule 93    functiontype -> VOID
Rule 94    functiontype -> type
Rule 95    add_func_quad_start -> <empty>
Rule 96    store_function -> <empty>
Rule 97    end_process -> <empty>
Rule 98    return -> RETURN sexpression SEMICOLON
Rule 99    parameter -> type ID store_parameter array parameterprima
Rule 100   parameter -> empty
Rule 101   parameterprima -> COMMA type ID store_parameter parameterprima
Rule 102   parameterprima -> empty
Rule 103   store_parameter -> <empty>
Rule 104   write -> PRINT LPAREN sexpression RPAREN SEMICOLON
Rule 105   read -> ID push_id_operand array ASSIGN push_operator INPUT LPAREN RPAREN SEMICOLON
Rule 106   cycle -> WHILE push_cycle_jump LPAREN sexpression RPAREN do_while_operation block
Rule 107   push_cycle_jump -> <empty>
Rule 108   do_while_operation -> <empty>
Rule 109   empty -> <empty>

Terminals, with rules where they appear

AND                  : 49
ASSIGN               : 34 105
BOOLEAN              : 
BOOLTYPE             : 33
COMMA                : 88 101
DIVIDE               : 60
ELSE                 : 20
EQUAL                : 45
FALSE                : 77
FLOAT                : 67
FLOATTYPE            : 31
FUNCTION             : 91
GREATER              : 44
GREATEROREQUAL       : 48
ID                   : 1 23 34 66 82 91 99 101 105
IF                   : 18
INPUT                : 105
INT                  : 68
INTTYPE              : 4 30
LBRACE               : 8
LBRACKET             : 26 72
LESS                 : 43
LESSOREQUAL          : 47
LPAREN               : 4 18 62 82 91 104 105 106
MAIN                 : 4
MINUS                : 55
NOT                  : 38
NOTEQUAL             : 46
OR                   : 50
PLUS                 : 54
PRINT                : 104
PROGRAM              : 1
RBRACE               : 8
RBRACKET             : 26 72
RETURN               : 98
RPAREN               : 4 18 62 82 91 104 105 106
SEMICOLON            : 1 16 23 34 98 104 105
STRING               : 70
STRINGTYPE           : 32
TIMES                : 59
TRUE                 : 76
VAR                  : 23
VOID                 : 93
WHILE                : 106
error                : 

Nonterminals, with rules where they appear

access_dimen_var     : 72
add_func_quad_start  : 91
add_global_function  : 1
add_jump_to_main     : 4
array                : 34 66 99 105
array_declaration    : 23
assignment           : 11
block                : 4 18 20 91 106
blockprima           : 8 9
bool                 : 69
calculate_dimen      : 26
change_to_global     : 4
check_function_existance : 82
condition            : 12
cycle                : 15
dimen_variable       : 26
do_condition_operation : 18
do_else_operation    : 20
do_math_operation1   : 52
do_math_operation2   : 57
do_not_operation     : 37
do_relational_operation : 41
do_while_operation   : 106
else                 : 18
empty                : 10 21 24 27 39 73 87 89 92 100 102
endProgram           : 1
end_process          : 91
exp                  : 41 42 52
expression           : 37 41
factor               : 57 58
funcargum            : 82
funcargumprima       : 86 88
function             : 1 91
functioncall         : 16 71
functiontype         : 91
generate_era         : 82
goto_main            : 1
main                 : 1
mathoperators1       : 52
mathoperators2       : 57
negation             : 37
parameter            : 91
parameterprima       : 99 101
pop_false_bottom     : 62
program              : 0
push_bool_operand    : 69
push_cycle_jump      : 106
push_false_bottom    : 62
push_float_operand   : 67
push_id_operand      : 34 66 105
push_int_operand     : 68
push_operator        : 34 38 41 52 57 105
push_string_operand  : 70
read                 : 14
relationaloperators  : 41
return               : 17
sexpression          : 18 26 34 62 72 86 88 98 104 106
statute              : 9
store_argument       : 86 88
store_function       : 91
store_parameter      : 99 101
store_variable       : 23
term                 : 52 53 57
type                 : 23 94 99 101
validate_arguments   : 82
validate_index       : 72
varConst             : 63
vars                 : 1 23 91
write                : 13

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID add_global_function SEMICOLON goto_main vars function main endProgram

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID add_global_function SEMICOLON goto_main vars function main endProgram

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . add_global_function SEMICOLON goto_main vars function main endProgram
    (3) add_global_function -> .

    SEMICOLON       reduce using rule 3 (add_global_function -> .)

    add_global_function            shift and go to state 4

state 4

    (1) program -> PROGRAM ID add_global_function . SEMICOLON goto_main vars function main endProgram

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM ID add_global_function SEMICOLON . goto_main vars function main endProgram
    (6) goto_main -> .

    VAR             reduce using rule 6 (goto_main -> .)
    FUNCTION        reduce using rule 6 (goto_main -> .)
    INTTYPE         reduce using rule 6 (goto_main -> .)

    goto_main                      shift and go to state 6

state 6

    (1) program -> PROGRAM ID add_global_function SEMICOLON goto_main . vars function main endProgram
    (23) vars -> . VAR type ID array_declaration store_variable SEMICOLON vars
    (24) vars -> . empty
    (109) empty -> .

    VAR             shift and go to state 8
    FUNCTION        reduce using rule 109 (empty -> .)
    INTTYPE         reduce using rule 109 (empty -> .)

    vars                           shift and go to state 7
    empty                          shift and go to state 9

state 7

    (1) program -> PROGRAM ID add_global_function SEMICOLON goto_main vars . function main endProgram
    (91) function -> . FUNCTION functiontype ID store_function LPAREN parameter RPAREN vars add_func_quad_start block end_process function
    (92) function -> . empty
    (109) empty -> .

    FUNCTION        shift and go to state 11
    INTTYPE         reduce using rule 109 (empty -> .)

    function                       shift and go to state 10
    empty                          shift and go to state 12

state 8

    (23) vars -> VAR . type ID array_declaration store_variable SEMICOLON vars
    (30) type -> . INTTYPE
    (31) type -> . FLOATTYPE
    (32) type -> . STRINGTYPE
    (33) type -> . BOOLTYPE

    INTTYPE         shift and go to state 16
    FLOATTYPE       shift and go to state 15
    STRINGTYPE      shift and go to state 14
    BOOLTYPE        shift and go to state 13

    type                           shift and go to state 17

state 9

    (24) vars -> empty .

    FUNCTION        reduce using rule 24 (vars -> empty .)
    INTTYPE         reduce using rule 24 (vars -> empty .)
    LBRACE          reduce using rule 24 (vars -> empty .)


state 10

    (1) program -> PROGRAM ID add_global_function SEMICOLON goto_main vars function . main endProgram
    (4) main -> . INTTYPE MAIN change_to_global LPAREN RPAREN add_jump_to_main block

    INTTYPE         shift and go to state 18

    main                           shift and go to state 19

state 11

    (91) function -> FUNCTION . functiontype ID store_function LPAREN parameter RPAREN vars add_func_quad_start block end_process function
    (93) functiontype -> . VOID
    (94) functiontype -> . type
    (30) type -> . INTTYPE
    (31) type -> . FLOATTYPE
    (32) type -> . STRINGTYPE
    (33) type -> . BOOLTYPE

    VOID            shift and go to state 21
    INTTYPE         shift and go to state 16
    FLOATTYPE       shift and go to state 15
    STRINGTYPE      shift and go to state 14
    BOOLTYPE        shift and go to state 13

    functiontype                   shift and go to state 20
    type                           shift and go to state 22

state 12

    (92) function -> empty .

    INTTYPE         reduce using rule 92 (function -> empty .)


state 13

    (33) type -> BOOLTYPE .

    ID              reduce using rule 33 (type -> BOOLTYPE .)


state 14

    (32) type -> STRINGTYPE .

    ID              reduce using rule 32 (type -> STRINGTYPE .)


state 15

    (31) type -> FLOATTYPE .

    ID              reduce using rule 31 (type -> FLOATTYPE .)


state 16

    (30) type -> INTTYPE .

    ID              reduce using rule 30 (type -> INTTYPE .)


state 17

    (23) vars -> VAR type . ID array_declaration store_variable SEMICOLON vars

    ID              shift and go to state 23


state 18

    (4) main -> INTTYPE . MAIN change_to_global LPAREN RPAREN add_jump_to_main block

    MAIN            shift and go to state 24


state 19

    (1) program -> PROGRAM ID add_global_function SEMICOLON goto_main vars function main . endProgram
    (2) endProgram -> .

    $end            reduce using rule 2 (endProgram -> .)

    endProgram                     shift and go to state 25

state 20

    (91) function -> FUNCTION functiontype . ID store_function LPAREN parameter RPAREN vars add_func_quad_start block end_process function

    ID              shift and go to state 26


state 21

    (93) functiontype -> VOID .

    ID              reduce using rule 93 (functiontype -> VOID .)


state 22

    (94) functiontype -> type .

    ID              reduce using rule 94 (functiontype -> type .)


state 23

    (23) vars -> VAR type ID . array_declaration store_variable SEMICOLON vars
    (26) array_declaration -> . LBRACKET dimen_variable sexpression calculate_dimen RBRACKET
    (27) array_declaration -> . empty
    (109) empty -> .

    LBRACKET        shift and go to state 27
    SEMICOLON       reduce using rule 109 (empty -> .)

    array_declaration              shift and go to state 28
    empty                          shift and go to state 29

state 24

    (4) main -> INTTYPE MAIN . change_to_global LPAREN RPAREN add_jump_to_main block
    (5) change_to_global -> .

    LPAREN          reduce using rule 5 (change_to_global -> .)

    change_to_global               shift and go to state 30

state 25

    (1) program -> PROGRAM ID add_global_function SEMICOLON goto_main vars function main endProgram .

    $end            reduce using rule 1 (program -> PROGRAM ID add_global_function SEMICOLON goto_main vars function main endProgram .)


state 26

    (91) function -> FUNCTION functiontype ID . store_function LPAREN parameter RPAREN vars add_func_quad_start block end_process function
    (96) store_function -> .

    LPAREN          reduce using rule 96 (store_function -> .)

    store_function                 shift and go to state 31

state 27

    (26) array_declaration -> LBRACKET . dimen_variable sexpression calculate_dimen RBRACKET
    (28) dimen_variable -> .

    NOT             reduce using rule 28 (dimen_variable -> .)
    LPAREN          reduce using rule 28 (dimen_variable -> .)
    ID              reduce using rule 28 (dimen_variable -> .)
    FLOAT           reduce using rule 28 (dimen_variable -> .)
    INT             reduce using rule 28 (dimen_variable -> .)
    STRING          reduce using rule 28 (dimen_variable -> .)
    TRUE            reduce using rule 28 (dimen_variable -> .)
    FALSE           reduce using rule 28 (dimen_variable -> .)

    dimen_variable                 shift and go to state 32

state 28

    (23) vars -> VAR type ID array_declaration . store_variable SEMICOLON vars
    (25) store_variable -> .

    SEMICOLON       reduce using rule 25 (store_variable -> .)

    store_variable                 shift and go to state 33

state 29

    (27) array_declaration -> empty .

    SEMICOLON       reduce using rule 27 (array_declaration -> empty .)


state 30

    (4) main -> INTTYPE MAIN change_to_global . LPAREN RPAREN add_jump_to_main block

    LPAREN          shift and go to state 34


state 31

    (91) function -> FUNCTION functiontype ID store_function . LPAREN parameter RPAREN vars add_func_quad_start block end_process function

    LPAREN          shift and go to state 35


state 32

    (26) array_declaration -> LBRACKET dimen_variable . sexpression calculate_dimen RBRACKET
    (37) sexpression -> . negation expression do_not_operation
    (38) negation -> . NOT push_operator
    (39) negation -> . empty
    (109) empty -> .

    NOT             shift and go to state 38
    LPAREN          reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FLOAT           reduce using rule 109 (empty -> .)
    INT             reduce using rule 109 (empty -> .)
    STRING          reduce using rule 109 (empty -> .)
    TRUE            reduce using rule 109 (empty -> .)
    FALSE           reduce using rule 109 (empty -> .)

    negation                       shift and go to state 36
    sexpression                    shift and go to state 37
    empty                          shift and go to state 39

state 33

    (23) vars -> VAR type ID array_declaration store_variable . SEMICOLON vars

    SEMICOLON       shift and go to state 40


state 34

    (4) main -> INTTYPE MAIN change_to_global LPAREN . RPAREN add_jump_to_main block

    RPAREN          shift and go to state 41


state 35

    (91) function -> FUNCTION functiontype ID store_function LPAREN . parameter RPAREN vars add_func_quad_start block end_process function
    (99) parameter -> . type ID store_parameter array parameterprima
    (100) parameter -> . empty
    (30) type -> . INTTYPE
    (31) type -> . FLOATTYPE
    (32) type -> . STRINGTYPE
    (33) type -> . BOOLTYPE
    (109) empty -> .

    INTTYPE         shift and go to state 16
    FLOATTYPE       shift and go to state 15
    STRINGTYPE      shift and go to state 14
    BOOLTYPE        shift and go to state 13
    RPAREN          reduce using rule 109 (empty -> .)

    empty                          shift and go to state 42
    type                           shift and go to state 43
    parameter                      shift and go to state 44

state 36

    (37) sexpression -> negation . expression do_not_operation
    (41) expression -> . expression relationaloperators push_operator exp do_relational_operation
    (42) expression -> . exp
    (52) exp -> . exp mathoperators1 push_operator term do_math_operation1
    (53) exp -> . term
    (57) term -> . term mathoperators2 push_operator factor do_math_operation2
    (58) term -> . factor
    (62) factor -> . LPAREN push_false_bottom sexpression RPAREN pop_false_bottom
    (63) factor -> . varConst
    (66) varConst -> . ID push_id_operand array
    (67) varConst -> . FLOAT push_float_operand
    (68) varConst -> . INT push_int_operand
    (69) varConst -> . bool push_bool_operand
    (70) varConst -> . STRING push_string_operand
    (71) varConst -> . functioncall
    (76) bool -> . TRUE
    (77) bool -> . FALSE
    (82) functioncall -> . ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments

    LPAREN          shift and go to state 52
    ID              shift and go to state 53
    FLOAT           shift and go to state 56
    INT             shift and go to state 55
    STRING          shift and go to state 47
    TRUE            shift and go to state 46
    FALSE           shift and go to state 48

    varConst                       shift and go to state 45
    bool                           shift and go to state 49
    factor                         shift and go to state 50
    exp                            shift and go to state 51
    term                           shift and go to state 54
    functioncall                   shift and go to state 57
    expression                     shift and go to state 58

state 37

    (26) array_declaration -> LBRACKET dimen_variable sexpression . calculate_dimen RBRACKET
    (29) calculate_dimen -> .

    RBRACKET        reduce using rule 29 (calculate_dimen -> .)

    calculate_dimen                shift and go to state 59

state 38

    (38) negation -> NOT . push_operator
    (36) push_operator -> .

    LPAREN          reduce using rule 36 (push_operator -> .)
    ID              reduce using rule 36 (push_operator -> .)
    FLOAT           reduce using rule 36 (push_operator -> .)
    INT             reduce using rule 36 (push_operator -> .)
    STRING          reduce using rule 36 (push_operator -> .)
    TRUE            reduce using rule 36 (push_operator -> .)
    FALSE           reduce using rule 36 (push_operator -> .)

    push_operator                  shift and go to state 60

state 39

    (39) negation -> empty .

    LPAREN          reduce using rule 39 (negation -> empty .)
    ID              reduce using rule 39 (negation -> empty .)
    FLOAT           reduce using rule 39 (negation -> empty .)
    INT             reduce using rule 39 (negation -> empty .)
    STRING          reduce using rule 39 (negation -> empty .)
    TRUE            reduce using rule 39 (negation -> empty .)
    FALSE           reduce using rule 39 (negation -> empty .)


state 40

    (23) vars -> VAR type ID array_declaration store_variable SEMICOLON . vars
    (23) vars -> . VAR type ID array_declaration store_variable SEMICOLON vars
    (24) vars -> . empty
    (109) empty -> .

    VAR             shift and go to state 8
    FUNCTION        reduce using rule 109 (empty -> .)
    INTTYPE         reduce using rule 109 (empty -> .)
    LBRACE          reduce using rule 109 (empty -> .)

    empty                          shift and go to state 9
    vars                           shift and go to state 61

state 41

    (4) main -> INTTYPE MAIN change_to_global LPAREN RPAREN . add_jump_to_main block
    (7) add_jump_to_main -> .

    LBRACE          reduce using rule 7 (add_jump_to_main -> .)

    add_jump_to_main               shift and go to state 62

state 42

    (100) parameter -> empty .

    RPAREN          reduce using rule 100 (parameter -> empty .)


state 43

    (99) parameter -> type . ID store_parameter array parameterprima

    ID              shift and go to state 63


state 44

    (91) function -> FUNCTION functiontype ID store_function LPAREN parameter . RPAREN vars add_func_quad_start block end_process function

    RPAREN          shift and go to state 64


state 45

    (63) factor -> varConst .

    TIMES           reduce using rule 63 (factor -> varConst .)
    DIVIDE          reduce using rule 63 (factor -> varConst .)
    PLUS            reduce using rule 63 (factor -> varConst .)
    MINUS           reduce using rule 63 (factor -> varConst .)
    LESS            reduce using rule 63 (factor -> varConst .)
    GREATER         reduce using rule 63 (factor -> varConst .)
    EQUAL           reduce using rule 63 (factor -> varConst .)
    NOTEQUAL        reduce using rule 63 (factor -> varConst .)
    LESSOREQUAL     reduce using rule 63 (factor -> varConst .)
    GREATEROREQUAL  reduce using rule 63 (factor -> varConst .)
    AND             reduce using rule 63 (factor -> varConst .)
    OR              reduce using rule 63 (factor -> varConst .)
    RBRACKET        reduce using rule 63 (factor -> varConst .)
    RPAREN          reduce using rule 63 (factor -> varConst .)
    SEMICOLON       reduce using rule 63 (factor -> varConst .)
    COMMA           reduce using rule 63 (factor -> varConst .)


state 46

    (76) bool -> TRUE .

    TIMES           reduce using rule 76 (bool -> TRUE .)
    DIVIDE          reduce using rule 76 (bool -> TRUE .)
    PLUS            reduce using rule 76 (bool -> TRUE .)
    MINUS           reduce using rule 76 (bool -> TRUE .)
    LESS            reduce using rule 76 (bool -> TRUE .)
    GREATER         reduce using rule 76 (bool -> TRUE .)
    EQUAL           reduce using rule 76 (bool -> TRUE .)
    NOTEQUAL        reduce using rule 76 (bool -> TRUE .)
    LESSOREQUAL     reduce using rule 76 (bool -> TRUE .)
    GREATEROREQUAL  reduce using rule 76 (bool -> TRUE .)
    AND             reduce using rule 76 (bool -> TRUE .)
    OR              reduce using rule 76 (bool -> TRUE .)
    RBRACKET        reduce using rule 76 (bool -> TRUE .)
    RPAREN          reduce using rule 76 (bool -> TRUE .)
    SEMICOLON       reduce using rule 76 (bool -> TRUE .)
    COMMA           reduce using rule 76 (bool -> TRUE .)


state 47

    (70) varConst -> STRING . push_string_operand
    (81) push_string_operand -> .

    TIMES           reduce using rule 81 (push_string_operand -> .)
    DIVIDE          reduce using rule 81 (push_string_operand -> .)
    PLUS            reduce using rule 81 (push_string_operand -> .)
    MINUS           reduce using rule 81 (push_string_operand -> .)
    LESS            reduce using rule 81 (push_string_operand -> .)
    GREATER         reduce using rule 81 (push_string_operand -> .)
    EQUAL           reduce using rule 81 (push_string_operand -> .)
    NOTEQUAL        reduce using rule 81 (push_string_operand -> .)
    LESSOREQUAL     reduce using rule 81 (push_string_operand -> .)
    GREATEROREQUAL  reduce using rule 81 (push_string_operand -> .)
    AND             reduce using rule 81 (push_string_operand -> .)
    OR              reduce using rule 81 (push_string_operand -> .)
    RBRACKET        reduce using rule 81 (push_string_operand -> .)
    RPAREN          reduce using rule 81 (push_string_operand -> .)
    SEMICOLON       reduce using rule 81 (push_string_operand -> .)
    COMMA           reduce using rule 81 (push_string_operand -> .)

    push_string_operand            shift and go to state 65

state 48

    (77) bool -> FALSE .

    TIMES           reduce using rule 77 (bool -> FALSE .)
    DIVIDE          reduce using rule 77 (bool -> FALSE .)
    PLUS            reduce using rule 77 (bool -> FALSE .)
    MINUS           reduce using rule 77 (bool -> FALSE .)
    LESS            reduce using rule 77 (bool -> FALSE .)
    GREATER         reduce using rule 77 (bool -> FALSE .)
    EQUAL           reduce using rule 77 (bool -> FALSE .)
    NOTEQUAL        reduce using rule 77 (bool -> FALSE .)
    LESSOREQUAL     reduce using rule 77 (bool -> FALSE .)
    GREATEROREQUAL  reduce using rule 77 (bool -> FALSE .)
    AND             reduce using rule 77 (bool -> FALSE .)
    OR              reduce using rule 77 (bool -> FALSE .)
    RBRACKET        reduce using rule 77 (bool -> FALSE .)
    RPAREN          reduce using rule 77 (bool -> FALSE .)
    SEMICOLON       reduce using rule 77 (bool -> FALSE .)
    COMMA           reduce using rule 77 (bool -> FALSE .)


state 49

    (69) varConst -> bool . push_bool_operand
    (80) push_bool_operand -> .

    TIMES           reduce using rule 80 (push_bool_operand -> .)
    DIVIDE          reduce using rule 80 (push_bool_operand -> .)
    PLUS            reduce using rule 80 (push_bool_operand -> .)
    MINUS           reduce using rule 80 (push_bool_operand -> .)
    LESS            reduce using rule 80 (push_bool_operand -> .)
    GREATER         reduce using rule 80 (push_bool_operand -> .)
    EQUAL           reduce using rule 80 (push_bool_operand -> .)
    NOTEQUAL        reduce using rule 80 (push_bool_operand -> .)
    LESSOREQUAL     reduce using rule 80 (push_bool_operand -> .)
    GREATEROREQUAL  reduce using rule 80 (push_bool_operand -> .)
    AND             reduce using rule 80 (push_bool_operand -> .)
    OR              reduce using rule 80 (push_bool_operand -> .)
    RBRACKET        reduce using rule 80 (push_bool_operand -> .)
    RPAREN          reduce using rule 80 (push_bool_operand -> .)
    SEMICOLON       reduce using rule 80 (push_bool_operand -> .)
    COMMA           reduce using rule 80 (push_bool_operand -> .)

    push_bool_operand              shift and go to state 66

state 50

    (58) term -> factor .

    TIMES           reduce using rule 58 (term -> factor .)
    DIVIDE          reduce using rule 58 (term -> factor .)
    PLUS            reduce using rule 58 (term -> factor .)
    MINUS           reduce using rule 58 (term -> factor .)
    LESS            reduce using rule 58 (term -> factor .)
    GREATER         reduce using rule 58 (term -> factor .)
    EQUAL           reduce using rule 58 (term -> factor .)
    NOTEQUAL        reduce using rule 58 (term -> factor .)
    LESSOREQUAL     reduce using rule 58 (term -> factor .)
    GREATEROREQUAL  reduce using rule 58 (term -> factor .)
    AND             reduce using rule 58 (term -> factor .)
    OR              reduce using rule 58 (term -> factor .)
    RBRACKET        reduce using rule 58 (term -> factor .)
    RPAREN          reduce using rule 58 (term -> factor .)
    SEMICOLON       reduce using rule 58 (term -> factor .)
    COMMA           reduce using rule 58 (term -> factor .)


state 51

    (42) expression -> exp .
    (52) exp -> exp . mathoperators1 push_operator term do_math_operation1
    (54) mathoperators1 -> . PLUS
    (55) mathoperators1 -> . MINUS

    LESS            reduce using rule 42 (expression -> exp .)
    GREATER         reduce using rule 42 (expression -> exp .)
    EQUAL           reduce using rule 42 (expression -> exp .)
    NOTEQUAL        reduce using rule 42 (expression -> exp .)
    LESSOREQUAL     reduce using rule 42 (expression -> exp .)
    GREATEROREQUAL  reduce using rule 42 (expression -> exp .)
    AND             reduce using rule 42 (expression -> exp .)
    OR              reduce using rule 42 (expression -> exp .)
    RBRACKET        reduce using rule 42 (expression -> exp .)
    RPAREN          reduce using rule 42 (expression -> exp .)
    SEMICOLON       reduce using rule 42 (expression -> exp .)
    COMMA           reduce using rule 42 (expression -> exp .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 69

    mathoperators1                 shift and go to state 68

state 52

    (62) factor -> LPAREN . push_false_bottom sexpression RPAREN pop_false_bottom
    (64) push_false_bottom -> .

    NOT             reduce using rule 64 (push_false_bottom -> .)
    LPAREN          reduce using rule 64 (push_false_bottom -> .)
    ID              reduce using rule 64 (push_false_bottom -> .)
    FLOAT           reduce using rule 64 (push_false_bottom -> .)
    INT             reduce using rule 64 (push_false_bottom -> .)
    STRING          reduce using rule 64 (push_false_bottom -> .)
    TRUE            reduce using rule 64 (push_false_bottom -> .)
    FALSE           reduce using rule 64 (push_false_bottom -> .)

    push_false_bottom              shift and go to state 70

state 53

    (66) varConst -> ID . push_id_operand array
    (82) functioncall -> ID . check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments
    (35) push_id_operand -> .
    (83) check_function_existance -> .

    LBRACKET        reduce using rule 35 (push_id_operand -> .)
    TIMES           reduce using rule 35 (push_id_operand -> .)
    DIVIDE          reduce using rule 35 (push_id_operand -> .)
    PLUS            reduce using rule 35 (push_id_operand -> .)
    MINUS           reduce using rule 35 (push_id_operand -> .)
    LESS            reduce using rule 35 (push_id_operand -> .)
    GREATER         reduce using rule 35 (push_id_operand -> .)
    EQUAL           reduce using rule 35 (push_id_operand -> .)
    NOTEQUAL        reduce using rule 35 (push_id_operand -> .)
    LESSOREQUAL     reduce using rule 35 (push_id_operand -> .)
    GREATEROREQUAL  reduce using rule 35 (push_id_operand -> .)
    AND             reduce using rule 35 (push_id_operand -> .)
    OR              reduce using rule 35 (push_id_operand -> .)
    RBRACKET        reduce using rule 35 (push_id_operand -> .)
    RPAREN          reduce using rule 35 (push_id_operand -> .)
    SEMICOLON       reduce using rule 35 (push_id_operand -> .)
    COMMA           reduce using rule 35 (push_id_operand -> .)
    LPAREN          reduce using rule 83 (check_function_existance -> .)

    check_function_existance       shift and go to state 71
    push_id_operand                shift and go to state 72

state 54

    (53) exp -> term .
    (57) term -> term . mathoperators2 push_operator factor do_math_operation2
    (59) mathoperators2 -> . TIMES
    (60) mathoperators2 -> . DIVIDE

    PLUS            reduce using rule 53 (exp -> term .)
    MINUS           reduce using rule 53 (exp -> term .)
    LESS            reduce using rule 53 (exp -> term .)
    GREATER         reduce using rule 53 (exp -> term .)
    EQUAL           reduce using rule 53 (exp -> term .)
    NOTEQUAL        reduce using rule 53 (exp -> term .)
    LESSOREQUAL     reduce using rule 53 (exp -> term .)
    GREATEROREQUAL  reduce using rule 53 (exp -> term .)
    AND             reduce using rule 53 (exp -> term .)
    OR              reduce using rule 53 (exp -> term .)
    RBRACKET        reduce using rule 53 (exp -> term .)
    RPAREN          reduce using rule 53 (exp -> term .)
    SEMICOLON       reduce using rule 53 (exp -> term .)
    COMMA           reduce using rule 53 (exp -> term .)
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 73

    mathoperators2                 shift and go to state 75

state 55

    (68) varConst -> INT . push_int_operand
    (79) push_int_operand -> .

    TIMES           reduce using rule 79 (push_int_operand -> .)
    DIVIDE          reduce using rule 79 (push_int_operand -> .)
    PLUS            reduce using rule 79 (push_int_operand -> .)
    MINUS           reduce using rule 79 (push_int_operand -> .)
    LESS            reduce using rule 79 (push_int_operand -> .)
    GREATER         reduce using rule 79 (push_int_operand -> .)
    EQUAL           reduce using rule 79 (push_int_operand -> .)
    NOTEQUAL        reduce using rule 79 (push_int_operand -> .)
    LESSOREQUAL     reduce using rule 79 (push_int_operand -> .)
    GREATEROREQUAL  reduce using rule 79 (push_int_operand -> .)
    AND             reduce using rule 79 (push_int_operand -> .)
    OR              reduce using rule 79 (push_int_operand -> .)
    RBRACKET        reduce using rule 79 (push_int_operand -> .)
    RPAREN          reduce using rule 79 (push_int_operand -> .)
    SEMICOLON       reduce using rule 79 (push_int_operand -> .)
    COMMA           reduce using rule 79 (push_int_operand -> .)

    push_int_operand               shift and go to state 76

state 56

    (67) varConst -> FLOAT . push_float_operand
    (78) push_float_operand -> .

    TIMES           reduce using rule 78 (push_float_operand -> .)
    DIVIDE          reduce using rule 78 (push_float_operand -> .)
    PLUS            reduce using rule 78 (push_float_operand -> .)
    MINUS           reduce using rule 78 (push_float_operand -> .)
    LESS            reduce using rule 78 (push_float_operand -> .)
    GREATER         reduce using rule 78 (push_float_operand -> .)
    EQUAL           reduce using rule 78 (push_float_operand -> .)
    NOTEQUAL        reduce using rule 78 (push_float_operand -> .)
    LESSOREQUAL     reduce using rule 78 (push_float_operand -> .)
    GREATEROREQUAL  reduce using rule 78 (push_float_operand -> .)
    AND             reduce using rule 78 (push_float_operand -> .)
    OR              reduce using rule 78 (push_float_operand -> .)
    RBRACKET        reduce using rule 78 (push_float_operand -> .)
    RPAREN          reduce using rule 78 (push_float_operand -> .)
    SEMICOLON       reduce using rule 78 (push_float_operand -> .)
    COMMA           reduce using rule 78 (push_float_operand -> .)

    push_float_operand             shift and go to state 77

state 57

    (71) varConst -> functioncall .

    TIMES           reduce using rule 71 (varConst -> functioncall .)
    DIVIDE          reduce using rule 71 (varConst -> functioncall .)
    PLUS            reduce using rule 71 (varConst -> functioncall .)
    MINUS           reduce using rule 71 (varConst -> functioncall .)
    LESS            reduce using rule 71 (varConst -> functioncall .)
    GREATER         reduce using rule 71 (varConst -> functioncall .)
    EQUAL           reduce using rule 71 (varConst -> functioncall .)
    NOTEQUAL        reduce using rule 71 (varConst -> functioncall .)
    LESSOREQUAL     reduce using rule 71 (varConst -> functioncall .)
    GREATEROREQUAL  reduce using rule 71 (varConst -> functioncall .)
    AND             reduce using rule 71 (varConst -> functioncall .)
    OR              reduce using rule 71 (varConst -> functioncall .)
    RBRACKET        reduce using rule 71 (varConst -> functioncall .)
    RPAREN          reduce using rule 71 (varConst -> functioncall .)
    SEMICOLON       reduce using rule 71 (varConst -> functioncall .)
    COMMA           reduce using rule 71 (varConst -> functioncall .)


state 58

    (37) sexpression -> negation expression . do_not_operation
    (41) expression -> expression . relationaloperators push_operator exp do_relational_operation
    (40) do_not_operation -> .
    (43) relationaloperators -> . LESS
    (44) relationaloperators -> . GREATER
    (45) relationaloperators -> . EQUAL
    (46) relationaloperators -> . NOTEQUAL
    (47) relationaloperators -> . LESSOREQUAL
    (48) relationaloperators -> . GREATEROREQUAL
    (49) relationaloperators -> . AND
    (50) relationaloperators -> . OR

    RBRACKET        reduce using rule 40 (do_not_operation -> .)
    RPAREN          reduce using rule 40 (do_not_operation -> .)
    SEMICOLON       reduce using rule 40 (do_not_operation -> .)
    COMMA           reduce using rule 40 (do_not_operation -> .)
    LESS            shift and go to state 82
    GREATER         shift and go to state 81
    EQUAL           shift and go to state 83
    NOTEQUAL        shift and go to state 85
    LESSOREQUAL     shift and go to state 84
    GREATEROREQUAL  shift and go to state 86
    AND             shift and go to state 78
    OR              shift and go to state 87

    relationaloperators            shift and go to state 79
    do_not_operation               shift and go to state 80

state 59

    (26) array_declaration -> LBRACKET dimen_variable sexpression calculate_dimen . RBRACKET

    RBRACKET        shift and go to state 88


state 60

    (38) negation -> NOT push_operator .

    LPAREN          reduce using rule 38 (negation -> NOT push_operator .)
    ID              reduce using rule 38 (negation -> NOT push_operator .)
    FLOAT           reduce using rule 38 (negation -> NOT push_operator .)
    INT             reduce using rule 38 (negation -> NOT push_operator .)
    STRING          reduce using rule 38 (negation -> NOT push_operator .)
    TRUE            reduce using rule 38 (negation -> NOT push_operator .)
    FALSE           reduce using rule 38 (negation -> NOT push_operator .)


state 61

    (23) vars -> VAR type ID array_declaration store_variable SEMICOLON vars .

    FUNCTION        reduce using rule 23 (vars -> VAR type ID array_declaration store_variable SEMICOLON vars .)
    INTTYPE         reduce using rule 23 (vars -> VAR type ID array_declaration store_variable SEMICOLON vars .)
    LBRACE          reduce using rule 23 (vars -> VAR type ID array_declaration store_variable SEMICOLON vars .)


state 62

    (4) main -> INTTYPE MAIN change_to_global LPAREN RPAREN add_jump_to_main . block
    (8) block -> . LBRACE blockprima RBRACE

    LBRACE          shift and go to state 89

    block                          shift and go to state 90

state 63

    (99) parameter -> type ID . store_parameter array parameterprima
    (103) store_parameter -> .

    LBRACKET        reduce using rule 103 (store_parameter -> .)
    COMMA           reduce using rule 103 (store_parameter -> .)
    RPAREN          reduce using rule 103 (store_parameter -> .)

    store_parameter                shift and go to state 91

state 64

    (91) function -> FUNCTION functiontype ID store_function LPAREN parameter RPAREN . vars add_func_quad_start block end_process function
    (23) vars -> . VAR type ID array_declaration store_variable SEMICOLON vars
    (24) vars -> . empty
    (109) empty -> .

    VAR             shift and go to state 8
    LBRACE          reduce using rule 109 (empty -> .)

    vars                           shift and go to state 92
    empty                          shift and go to state 9

state 65

    (70) varConst -> STRING push_string_operand .

    TIMES           reduce using rule 70 (varConst -> STRING push_string_operand .)
    DIVIDE          reduce using rule 70 (varConst -> STRING push_string_operand .)
    PLUS            reduce using rule 70 (varConst -> STRING push_string_operand .)
    MINUS           reduce using rule 70 (varConst -> STRING push_string_operand .)
    LESS            reduce using rule 70 (varConst -> STRING push_string_operand .)
    GREATER         reduce using rule 70 (varConst -> STRING push_string_operand .)
    EQUAL           reduce using rule 70 (varConst -> STRING push_string_operand .)
    NOTEQUAL        reduce using rule 70 (varConst -> STRING push_string_operand .)
    LESSOREQUAL     reduce using rule 70 (varConst -> STRING push_string_operand .)
    GREATEROREQUAL  reduce using rule 70 (varConst -> STRING push_string_operand .)
    AND             reduce using rule 70 (varConst -> STRING push_string_operand .)
    OR              reduce using rule 70 (varConst -> STRING push_string_operand .)
    RBRACKET        reduce using rule 70 (varConst -> STRING push_string_operand .)
    RPAREN          reduce using rule 70 (varConst -> STRING push_string_operand .)
    SEMICOLON       reduce using rule 70 (varConst -> STRING push_string_operand .)
    COMMA           reduce using rule 70 (varConst -> STRING push_string_operand .)


state 66

    (69) varConst -> bool push_bool_operand .

    TIMES           reduce using rule 69 (varConst -> bool push_bool_operand .)
    DIVIDE          reduce using rule 69 (varConst -> bool push_bool_operand .)
    PLUS            reduce using rule 69 (varConst -> bool push_bool_operand .)
    MINUS           reduce using rule 69 (varConst -> bool push_bool_operand .)
    LESS            reduce using rule 69 (varConst -> bool push_bool_operand .)
    GREATER         reduce using rule 69 (varConst -> bool push_bool_operand .)
    EQUAL           reduce using rule 69 (varConst -> bool push_bool_operand .)
    NOTEQUAL        reduce using rule 69 (varConst -> bool push_bool_operand .)
    LESSOREQUAL     reduce using rule 69 (varConst -> bool push_bool_operand .)
    GREATEROREQUAL  reduce using rule 69 (varConst -> bool push_bool_operand .)
    AND             reduce using rule 69 (varConst -> bool push_bool_operand .)
    OR              reduce using rule 69 (varConst -> bool push_bool_operand .)
    RBRACKET        reduce using rule 69 (varConst -> bool push_bool_operand .)
    RPAREN          reduce using rule 69 (varConst -> bool push_bool_operand .)
    SEMICOLON       reduce using rule 69 (varConst -> bool push_bool_operand .)
    COMMA           reduce using rule 69 (varConst -> bool push_bool_operand .)


state 67

    (54) mathoperators1 -> PLUS .

    LPAREN          reduce using rule 54 (mathoperators1 -> PLUS .)
    ID              reduce using rule 54 (mathoperators1 -> PLUS .)
    FLOAT           reduce using rule 54 (mathoperators1 -> PLUS .)
    INT             reduce using rule 54 (mathoperators1 -> PLUS .)
    STRING          reduce using rule 54 (mathoperators1 -> PLUS .)
    TRUE            reduce using rule 54 (mathoperators1 -> PLUS .)
    FALSE           reduce using rule 54 (mathoperators1 -> PLUS .)


state 68

    (52) exp -> exp mathoperators1 . push_operator term do_math_operation1
    (36) push_operator -> .

    LPAREN          reduce using rule 36 (push_operator -> .)
    ID              reduce using rule 36 (push_operator -> .)
    FLOAT           reduce using rule 36 (push_operator -> .)
    INT             reduce using rule 36 (push_operator -> .)
    STRING          reduce using rule 36 (push_operator -> .)
    TRUE            reduce using rule 36 (push_operator -> .)
    FALSE           reduce using rule 36 (push_operator -> .)

    push_operator                  shift and go to state 93

state 69

    (55) mathoperators1 -> MINUS .

    LPAREN          reduce using rule 55 (mathoperators1 -> MINUS .)
    ID              reduce using rule 55 (mathoperators1 -> MINUS .)
    FLOAT           reduce using rule 55 (mathoperators1 -> MINUS .)
    INT             reduce using rule 55 (mathoperators1 -> MINUS .)
    STRING          reduce using rule 55 (mathoperators1 -> MINUS .)
    TRUE            reduce using rule 55 (mathoperators1 -> MINUS .)
    FALSE           reduce using rule 55 (mathoperators1 -> MINUS .)


state 70

    (62) factor -> LPAREN push_false_bottom . sexpression RPAREN pop_false_bottom
    (37) sexpression -> . negation expression do_not_operation
    (38) negation -> . NOT push_operator
    (39) negation -> . empty
    (109) empty -> .

    NOT             shift and go to state 38
    LPAREN          reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FLOAT           reduce using rule 109 (empty -> .)
    INT             reduce using rule 109 (empty -> .)
    STRING          reduce using rule 109 (empty -> .)
    TRUE            reduce using rule 109 (empty -> .)
    FALSE           reduce using rule 109 (empty -> .)

    sexpression                    shift and go to state 94
    negation                       shift and go to state 36
    empty                          shift and go to state 39

state 71

    (82) functioncall -> ID check_function_existance . LPAREN generate_era funcargum RPAREN validate_arguments

    LPAREN          shift and go to state 95


state 72

    (66) varConst -> ID push_id_operand . array
    (72) array -> . LBRACKET access_dimen_var sexpression validate_index RBRACKET
    (73) array -> . empty
    (109) empty -> .

    LBRACKET        shift and go to state 96
    TIMES           reduce using rule 109 (empty -> .)
    DIVIDE          reduce using rule 109 (empty -> .)
    PLUS            reduce using rule 109 (empty -> .)
    MINUS           reduce using rule 109 (empty -> .)
    LESS            reduce using rule 109 (empty -> .)
    GREATER         reduce using rule 109 (empty -> .)
    EQUAL           reduce using rule 109 (empty -> .)
    NOTEQUAL        reduce using rule 109 (empty -> .)
    LESSOREQUAL     reduce using rule 109 (empty -> .)
    GREATEROREQUAL  reduce using rule 109 (empty -> .)
    AND             reduce using rule 109 (empty -> .)
    OR              reduce using rule 109 (empty -> .)
    RBRACKET        reduce using rule 109 (empty -> .)
    RPAREN          reduce using rule 109 (empty -> .)
    SEMICOLON       reduce using rule 109 (empty -> .)
    COMMA           reduce using rule 109 (empty -> .)

    array                          shift and go to state 97
    empty                          shift and go to state 98

state 73

    (60) mathoperators2 -> DIVIDE .

    LPAREN          reduce using rule 60 (mathoperators2 -> DIVIDE .)
    ID              reduce using rule 60 (mathoperators2 -> DIVIDE .)
    FLOAT           reduce using rule 60 (mathoperators2 -> DIVIDE .)
    INT             reduce using rule 60 (mathoperators2 -> DIVIDE .)
    STRING          reduce using rule 60 (mathoperators2 -> DIVIDE .)
    TRUE            reduce using rule 60 (mathoperators2 -> DIVIDE .)
    FALSE           reduce using rule 60 (mathoperators2 -> DIVIDE .)


state 74

    (59) mathoperators2 -> TIMES .

    LPAREN          reduce using rule 59 (mathoperators2 -> TIMES .)
    ID              reduce using rule 59 (mathoperators2 -> TIMES .)
    FLOAT           reduce using rule 59 (mathoperators2 -> TIMES .)
    INT             reduce using rule 59 (mathoperators2 -> TIMES .)
    STRING          reduce using rule 59 (mathoperators2 -> TIMES .)
    TRUE            reduce using rule 59 (mathoperators2 -> TIMES .)
    FALSE           reduce using rule 59 (mathoperators2 -> TIMES .)


state 75

    (57) term -> term mathoperators2 . push_operator factor do_math_operation2
    (36) push_operator -> .

    LPAREN          reduce using rule 36 (push_operator -> .)
    ID              reduce using rule 36 (push_operator -> .)
    FLOAT           reduce using rule 36 (push_operator -> .)
    INT             reduce using rule 36 (push_operator -> .)
    STRING          reduce using rule 36 (push_operator -> .)
    TRUE            reduce using rule 36 (push_operator -> .)
    FALSE           reduce using rule 36 (push_operator -> .)

    push_operator                  shift and go to state 99

state 76

    (68) varConst -> INT push_int_operand .

    TIMES           reduce using rule 68 (varConst -> INT push_int_operand .)
    DIVIDE          reduce using rule 68 (varConst -> INT push_int_operand .)
    PLUS            reduce using rule 68 (varConst -> INT push_int_operand .)
    MINUS           reduce using rule 68 (varConst -> INT push_int_operand .)
    LESS            reduce using rule 68 (varConst -> INT push_int_operand .)
    GREATER         reduce using rule 68 (varConst -> INT push_int_operand .)
    EQUAL           reduce using rule 68 (varConst -> INT push_int_operand .)
    NOTEQUAL        reduce using rule 68 (varConst -> INT push_int_operand .)
    LESSOREQUAL     reduce using rule 68 (varConst -> INT push_int_operand .)
    GREATEROREQUAL  reduce using rule 68 (varConst -> INT push_int_operand .)
    AND             reduce using rule 68 (varConst -> INT push_int_operand .)
    OR              reduce using rule 68 (varConst -> INT push_int_operand .)
    RBRACKET        reduce using rule 68 (varConst -> INT push_int_operand .)
    RPAREN          reduce using rule 68 (varConst -> INT push_int_operand .)
    SEMICOLON       reduce using rule 68 (varConst -> INT push_int_operand .)
    COMMA           reduce using rule 68 (varConst -> INT push_int_operand .)


state 77

    (67) varConst -> FLOAT push_float_operand .

    TIMES           reduce using rule 67 (varConst -> FLOAT push_float_operand .)
    DIVIDE          reduce using rule 67 (varConst -> FLOAT push_float_operand .)
    PLUS            reduce using rule 67 (varConst -> FLOAT push_float_operand .)
    MINUS           reduce using rule 67 (varConst -> FLOAT push_float_operand .)
    LESS            reduce using rule 67 (varConst -> FLOAT push_float_operand .)
    GREATER         reduce using rule 67 (varConst -> FLOAT push_float_operand .)
    EQUAL           reduce using rule 67 (varConst -> FLOAT push_float_operand .)
    NOTEQUAL        reduce using rule 67 (varConst -> FLOAT push_float_operand .)
    LESSOREQUAL     reduce using rule 67 (varConst -> FLOAT push_float_operand .)
    GREATEROREQUAL  reduce using rule 67 (varConst -> FLOAT push_float_operand .)
    AND             reduce using rule 67 (varConst -> FLOAT push_float_operand .)
    OR              reduce using rule 67 (varConst -> FLOAT push_float_operand .)
    RBRACKET        reduce using rule 67 (varConst -> FLOAT push_float_operand .)
    RPAREN          reduce using rule 67 (varConst -> FLOAT push_float_operand .)
    SEMICOLON       reduce using rule 67 (varConst -> FLOAT push_float_operand .)
    COMMA           reduce using rule 67 (varConst -> FLOAT push_float_operand .)


state 78

    (49) relationaloperators -> AND .

    LPAREN          reduce using rule 49 (relationaloperators -> AND .)
    ID              reduce using rule 49 (relationaloperators -> AND .)
    FLOAT           reduce using rule 49 (relationaloperators -> AND .)
    INT             reduce using rule 49 (relationaloperators -> AND .)
    STRING          reduce using rule 49 (relationaloperators -> AND .)
    TRUE            reduce using rule 49 (relationaloperators -> AND .)
    FALSE           reduce using rule 49 (relationaloperators -> AND .)


state 79

    (41) expression -> expression relationaloperators . push_operator exp do_relational_operation
    (36) push_operator -> .

    LPAREN          reduce using rule 36 (push_operator -> .)
    ID              reduce using rule 36 (push_operator -> .)
    FLOAT           reduce using rule 36 (push_operator -> .)
    INT             reduce using rule 36 (push_operator -> .)
    STRING          reduce using rule 36 (push_operator -> .)
    TRUE            reduce using rule 36 (push_operator -> .)
    FALSE           reduce using rule 36 (push_operator -> .)

    push_operator                  shift and go to state 100

state 80

    (37) sexpression -> negation expression do_not_operation .

    RPAREN          reduce using rule 37 (sexpression -> negation expression do_not_operation .)
    RBRACKET        reduce using rule 37 (sexpression -> negation expression do_not_operation .)
    COMMA           reduce using rule 37 (sexpression -> negation expression do_not_operation .)
    SEMICOLON       reduce using rule 37 (sexpression -> negation expression do_not_operation .)


state 81

    (44) relationaloperators -> GREATER .

    LPAREN          reduce using rule 44 (relationaloperators -> GREATER .)
    ID              reduce using rule 44 (relationaloperators -> GREATER .)
    FLOAT           reduce using rule 44 (relationaloperators -> GREATER .)
    INT             reduce using rule 44 (relationaloperators -> GREATER .)
    STRING          reduce using rule 44 (relationaloperators -> GREATER .)
    TRUE            reduce using rule 44 (relationaloperators -> GREATER .)
    FALSE           reduce using rule 44 (relationaloperators -> GREATER .)


state 82

    (43) relationaloperators -> LESS .

    LPAREN          reduce using rule 43 (relationaloperators -> LESS .)
    ID              reduce using rule 43 (relationaloperators -> LESS .)
    FLOAT           reduce using rule 43 (relationaloperators -> LESS .)
    INT             reduce using rule 43 (relationaloperators -> LESS .)
    STRING          reduce using rule 43 (relationaloperators -> LESS .)
    TRUE            reduce using rule 43 (relationaloperators -> LESS .)
    FALSE           reduce using rule 43 (relationaloperators -> LESS .)


state 83

    (45) relationaloperators -> EQUAL .

    LPAREN          reduce using rule 45 (relationaloperators -> EQUAL .)
    ID              reduce using rule 45 (relationaloperators -> EQUAL .)
    FLOAT           reduce using rule 45 (relationaloperators -> EQUAL .)
    INT             reduce using rule 45 (relationaloperators -> EQUAL .)
    STRING          reduce using rule 45 (relationaloperators -> EQUAL .)
    TRUE            reduce using rule 45 (relationaloperators -> EQUAL .)
    FALSE           reduce using rule 45 (relationaloperators -> EQUAL .)


state 84

    (47) relationaloperators -> LESSOREQUAL .

    LPAREN          reduce using rule 47 (relationaloperators -> LESSOREQUAL .)
    ID              reduce using rule 47 (relationaloperators -> LESSOREQUAL .)
    FLOAT           reduce using rule 47 (relationaloperators -> LESSOREQUAL .)
    INT             reduce using rule 47 (relationaloperators -> LESSOREQUAL .)
    STRING          reduce using rule 47 (relationaloperators -> LESSOREQUAL .)
    TRUE            reduce using rule 47 (relationaloperators -> LESSOREQUAL .)
    FALSE           reduce using rule 47 (relationaloperators -> LESSOREQUAL .)


state 85

    (46) relationaloperators -> NOTEQUAL .

    LPAREN          reduce using rule 46 (relationaloperators -> NOTEQUAL .)
    ID              reduce using rule 46 (relationaloperators -> NOTEQUAL .)
    FLOAT           reduce using rule 46 (relationaloperators -> NOTEQUAL .)
    INT             reduce using rule 46 (relationaloperators -> NOTEQUAL .)
    STRING          reduce using rule 46 (relationaloperators -> NOTEQUAL .)
    TRUE            reduce using rule 46 (relationaloperators -> NOTEQUAL .)
    FALSE           reduce using rule 46 (relationaloperators -> NOTEQUAL .)


state 86

    (48) relationaloperators -> GREATEROREQUAL .

    LPAREN          reduce using rule 48 (relationaloperators -> GREATEROREQUAL .)
    ID              reduce using rule 48 (relationaloperators -> GREATEROREQUAL .)
    FLOAT           reduce using rule 48 (relationaloperators -> GREATEROREQUAL .)
    INT             reduce using rule 48 (relationaloperators -> GREATEROREQUAL .)
    STRING          reduce using rule 48 (relationaloperators -> GREATEROREQUAL .)
    TRUE            reduce using rule 48 (relationaloperators -> GREATEROREQUAL .)
    FALSE           reduce using rule 48 (relationaloperators -> GREATEROREQUAL .)


state 87

    (50) relationaloperators -> OR .

    LPAREN          reduce using rule 50 (relationaloperators -> OR .)
    ID              reduce using rule 50 (relationaloperators -> OR .)
    FLOAT           reduce using rule 50 (relationaloperators -> OR .)
    INT             reduce using rule 50 (relationaloperators -> OR .)
    STRING          reduce using rule 50 (relationaloperators -> OR .)
    TRUE            reduce using rule 50 (relationaloperators -> OR .)
    FALSE           reduce using rule 50 (relationaloperators -> OR .)


state 88

    (26) array_declaration -> LBRACKET dimen_variable sexpression calculate_dimen RBRACKET .

    SEMICOLON       reduce using rule 26 (array_declaration -> LBRACKET dimen_variable sexpression calculate_dimen RBRACKET .)


state 89

    (8) block -> LBRACE . blockprima RBRACE
    (9) blockprima -> . statute blockprima
    (10) blockprima -> . empty
    (11) statute -> . assignment
    (12) statute -> . condition
    (13) statute -> . write
    (14) statute -> . read
    (15) statute -> . cycle
    (16) statute -> . functioncall SEMICOLON
    (17) statute -> . return
    (109) empty -> .
    (34) assignment -> . ID push_id_operand array ASSIGN push_operator sexpression SEMICOLON
    (18) condition -> . IF LPAREN sexpression RPAREN do_condition_operation block else
    (104) write -> . PRINT LPAREN sexpression RPAREN SEMICOLON
    (105) read -> . ID push_id_operand array ASSIGN push_operator INPUT LPAREN RPAREN SEMICOLON
    (106) cycle -> . WHILE push_cycle_jump LPAREN sexpression RPAREN do_while_operation block
    (82) functioncall -> . ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments
    (98) return -> . RETURN sexpression SEMICOLON

    RBRACE          reduce using rule 109 (empty -> .)
    ID              shift and go to state 111
    IF              shift and go to state 113
    PRINT           shift and go to state 103
    WHILE           shift and go to state 102
    RETURN          shift and go to state 101

    blockprima                     shift and go to state 104
    write                          shift and go to state 105
    empty                          shift and go to state 107
    return                         shift and go to state 108
    read                           shift and go to state 109
    assignment                     shift and go to state 110
    condition                      shift and go to state 112
    cycle                          shift and go to state 106
    statute                        shift and go to state 114
    functioncall                   shift and go to state 115

state 90

    (4) main -> INTTYPE MAIN change_to_global LPAREN RPAREN add_jump_to_main block .

    $end            reduce using rule 4 (main -> INTTYPE MAIN change_to_global LPAREN RPAREN add_jump_to_main block .)


state 91

    (99) parameter -> type ID store_parameter . array parameterprima
    (72) array -> . LBRACKET access_dimen_var sexpression validate_index RBRACKET
    (73) array -> . empty
    (109) empty -> .

    LBRACKET        shift and go to state 96
    COMMA           reduce using rule 109 (empty -> .)
    RPAREN          reduce using rule 109 (empty -> .)

    array                          shift and go to state 116
    empty                          shift and go to state 98

state 92

    (91) function -> FUNCTION functiontype ID store_function LPAREN parameter RPAREN vars . add_func_quad_start block end_process function
    (95) add_func_quad_start -> .

    LBRACE          reduce using rule 95 (add_func_quad_start -> .)

    add_func_quad_start            shift and go to state 117

state 93

    (52) exp -> exp mathoperators1 push_operator . term do_math_operation1
    (57) term -> . term mathoperators2 push_operator factor do_math_operation2
    (58) term -> . factor
    (62) factor -> . LPAREN push_false_bottom sexpression RPAREN pop_false_bottom
    (63) factor -> . varConst
    (66) varConst -> . ID push_id_operand array
    (67) varConst -> . FLOAT push_float_operand
    (68) varConst -> . INT push_int_operand
    (69) varConst -> . bool push_bool_operand
    (70) varConst -> . STRING push_string_operand
    (71) varConst -> . functioncall
    (76) bool -> . TRUE
    (77) bool -> . FALSE
    (82) functioncall -> . ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments

    LPAREN          shift and go to state 52
    ID              shift and go to state 53
    FLOAT           shift and go to state 56
    INT             shift and go to state 55
    STRING          shift and go to state 47
    TRUE            shift and go to state 46
    FALSE           shift and go to state 48

    varConst                       shift and go to state 45
    bool                           shift and go to state 49
    factor                         shift and go to state 50
    term                           shift and go to state 118
    functioncall                   shift and go to state 57

state 94

    (62) factor -> LPAREN push_false_bottom sexpression . RPAREN pop_false_bottom

    RPAREN          shift and go to state 119


state 95

    (82) functioncall -> ID check_function_existance LPAREN . generate_era funcargum RPAREN validate_arguments
    (84) generate_era -> .

    NOT             reduce using rule 84 (generate_era -> .)
    RPAREN          reduce using rule 84 (generate_era -> .)
    LPAREN          reduce using rule 84 (generate_era -> .)
    ID              reduce using rule 84 (generate_era -> .)
    FLOAT           reduce using rule 84 (generate_era -> .)
    INT             reduce using rule 84 (generate_era -> .)
    STRING          reduce using rule 84 (generate_era -> .)
    TRUE            reduce using rule 84 (generate_era -> .)
    FALSE           reduce using rule 84 (generate_era -> .)

    generate_era                   shift and go to state 120

state 96

    (72) array -> LBRACKET . access_dimen_var sexpression validate_index RBRACKET
    (75) access_dimen_var -> .

    NOT             reduce using rule 75 (access_dimen_var -> .)
    LPAREN          reduce using rule 75 (access_dimen_var -> .)
    ID              reduce using rule 75 (access_dimen_var -> .)
    FLOAT           reduce using rule 75 (access_dimen_var -> .)
    INT             reduce using rule 75 (access_dimen_var -> .)
    STRING          reduce using rule 75 (access_dimen_var -> .)
    TRUE            reduce using rule 75 (access_dimen_var -> .)
    FALSE           reduce using rule 75 (access_dimen_var -> .)

    access_dimen_var               shift and go to state 121

state 97

    (66) varConst -> ID push_id_operand array .

    TIMES           reduce using rule 66 (varConst -> ID push_id_operand array .)
    DIVIDE          reduce using rule 66 (varConst -> ID push_id_operand array .)
    PLUS            reduce using rule 66 (varConst -> ID push_id_operand array .)
    MINUS           reduce using rule 66 (varConst -> ID push_id_operand array .)
    LESS            reduce using rule 66 (varConst -> ID push_id_operand array .)
    GREATER         reduce using rule 66 (varConst -> ID push_id_operand array .)
    EQUAL           reduce using rule 66 (varConst -> ID push_id_operand array .)
    NOTEQUAL        reduce using rule 66 (varConst -> ID push_id_operand array .)
    LESSOREQUAL     reduce using rule 66 (varConst -> ID push_id_operand array .)
    GREATEROREQUAL  reduce using rule 66 (varConst -> ID push_id_operand array .)
    AND             reduce using rule 66 (varConst -> ID push_id_operand array .)
    OR              reduce using rule 66 (varConst -> ID push_id_operand array .)
    RBRACKET        reduce using rule 66 (varConst -> ID push_id_operand array .)
    RPAREN          reduce using rule 66 (varConst -> ID push_id_operand array .)
    SEMICOLON       reduce using rule 66 (varConst -> ID push_id_operand array .)
    COMMA           reduce using rule 66 (varConst -> ID push_id_operand array .)


state 98

    (73) array -> empty .

    COMMA           reduce using rule 73 (array -> empty .)
    RPAREN          reduce using rule 73 (array -> empty .)
    ASSIGN          reduce using rule 73 (array -> empty .)
    TIMES           reduce using rule 73 (array -> empty .)
    DIVIDE          reduce using rule 73 (array -> empty .)
    PLUS            reduce using rule 73 (array -> empty .)
    MINUS           reduce using rule 73 (array -> empty .)
    LESS            reduce using rule 73 (array -> empty .)
    GREATER         reduce using rule 73 (array -> empty .)
    EQUAL           reduce using rule 73 (array -> empty .)
    NOTEQUAL        reduce using rule 73 (array -> empty .)
    LESSOREQUAL     reduce using rule 73 (array -> empty .)
    GREATEROREQUAL  reduce using rule 73 (array -> empty .)
    AND             reduce using rule 73 (array -> empty .)
    OR              reduce using rule 73 (array -> empty .)
    RBRACKET        reduce using rule 73 (array -> empty .)
    SEMICOLON       reduce using rule 73 (array -> empty .)


state 99

    (57) term -> term mathoperators2 push_operator . factor do_math_operation2
    (62) factor -> . LPAREN push_false_bottom sexpression RPAREN pop_false_bottom
    (63) factor -> . varConst
    (66) varConst -> . ID push_id_operand array
    (67) varConst -> . FLOAT push_float_operand
    (68) varConst -> . INT push_int_operand
    (69) varConst -> . bool push_bool_operand
    (70) varConst -> . STRING push_string_operand
    (71) varConst -> . functioncall
    (76) bool -> . TRUE
    (77) bool -> . FALSE
    (82) functioncall -> . ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments

    LPAREN          shift and go to state 52
    ID              shift and go to state 53
    FLOAT           shift and go to state 56
    INT             shift and go to state 55
    STRING          shift and go to state 47
    TRUE            shift and go to state 46
    FALSE           shift and go to state 48

    varConst                       shift and go to state 45
    bool                           shift and go to state 49
    factor                         shift and go to state 122
    functioncall                   shift and go to state 57

state 100

    (41) expression -> expression relationaloperators push_operator . exp do_relational_operation
    (52) exp -> . exp mathoperators1 push_operator term do_math_operation1
    (53) exp -> . term
    (57) term -> . term mathoperators2 push_operator factor do_math_operation2
    (58) term -> . factor
    (62) factor -> . LPAREN push_false_bottom sexpression RPAREN pop_false_bottom
    (63) factor -> . varConst
    (66) varConst -> . ID push_id_operand array
    (67) varConst -> . FLOAT push_float_operand
    (68) varConst -> . INT push_int_operand
    (69) varConst -> . bool push_bool_operand
    (70) varConst -> . STRING push_string_operand
    (71) varConst -> . functioncall
    (76) bool -> . TRUE
    (77) bool -> . FALSE
    (82) functioncall -> . ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments

    LPAREN          shift and go to state 52
    ID              shift and go to state 53
    FLOAT           shift and go to state 56
    INT             shift and go to state 55
    STRING          shift and go to state 47
    TRUE            shift and go to state 46
    FALSE           shift and go to state 48

    varConst                       shift and go to state 45
    bool                           shift and go to state 49
    factor                         shift and go to state 50
    exp                            shift and go to state 123
    term                           shift and go to state 54
    functioncall                   shift and go to state 57

state 101

    (98) return -> RETURN . sexpression SEMICOLON
    (37) sexpression -> . negation expression do_not_operation
    (38) negation -> . NOT push_operator
    (39) negation -> . empty
    (109) empty -> .

    NOT             shift and go to state 38
    LPAREN          reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FLOAT           reduce using rule 109 (empty -> .)
    INT             reduce using rule 109 (empty -> .)
    STRING          reduce using rule 109 (empty -> .)
    TRUE            reduce using rule 109 (empty -> .)
    FALSE           reduce using rule 109 (empty -> .)

    negation                       shift and go to state 36
    sexpression                    shift and go to state 124
    empty                          shift and go to state 39

state 102

    (106) cycle -> WHILE . push_cycle_jump LPAREN sexpression RPAREN do_while_operation block
    (107) push_cycle_jump -> .

    LPAREN          reduce using rule 107 (push_cycle_jump -> .)

    push_cycle_jump                shift and go to state 125

state 103

    (104) write -> PRINT . LPAREN sexpression RPAREN SEMICOLON

    LPAREN          shift and go to state 126


state 104

    (8) block -> LBRACE blockprima . RBRACE

    RBRACE          shift and go to state 127


state 105

    (13) statute -> write .

    ID              reduce using rule 13 (statute -> write .)
    IF              reduce using rule 13 (statute -> write .)
    PRINT           reduce using rule 13 (statute -> write .)
    WHILE           reduce using rule 13 (statute -> write .)
    RETURN          reduce using rule 13 (statute -> write .)
    RBRACE          reduce using rule 13 (statute -> write .)


state 106

    (15) statute -> cycle .

    ID              reduce using rule 15 (statute -> cycle .)
    IF              reduce using rule 15 (statute -> cycle .)
    PRINT           reduce using rule 15 (statute -> cycle .)
    WHILE           reduce using rule 15 (statute -> cycle .)
    RETURN          reduce using rule 15 (statute -> cycle .)
    RBRACE          reduce using rule 15 (statute -> cycle .)


state 107

    (10) blockprima -> empty .

    RBRACE          reduce using rule 10 (blockprima -> empty .)


state 108

    (17) statute -> return .

    ID              reduce using rule 17 (statute -> return .)
    IF              reduce using rule 17 (statute -> return .)
    PRINT           reduce using rule 17 (statute -> return .)
    WHILE           reduce using rule 17 (statute -> return .)
    RETURN          reduce using rule 17 (statute -> return .)
    RBRACE          reduce using rule 17 (statute -> return .)


state 109

    (14) statute -> read .

    ID              reduce using rule 14 (statute -> read .)
    IF              reduce using rule 14 (statute -> read .)
    PRINT           reduce using rule 14 (statute -> read .)
    WHILE           reduce using rule 14 (statute -> read .)
    RETURN          reduce using rule 14 (statute -> read .)
    RBRACE          reduce using rule 14 (statute -> read .)


state 110

    (11) statute -> assignment .

    ID              reduce using rule 11 (statute -> assignment .)
    IF              reduce using rule 11 (statute -> assignment .)
    PRINT           reduce using rule 11 (statute -> assignment .)
    WHILE           reduce using rule 11 (statute -> assignment .)
    RETURN          reduce using rule 11 (statute -> assignment .)
    RBRACE          reduce using rule 11 (statute -> assignment .)


state 111

    (34) assignment -> ID . push_id_operand array ASSIGN push_operator sexpression SEMICOLON
    (105) read -> ID . push_id_operand array ASSIGN push_operator INPUT LPAREN RPAREN SEMICOLON
    (82) functioncall -> ID . check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments
    (35) push_id_operand -> .
    (83) check_function_existance -> .

    LBRACKET        reduce using rule 35 (push_id_operand -> .)
    ASSIGN          reduce using rule 35 (push_id_operand -> .)
    LPAREN          reduce using rule 83 (check_function_existance -> .)

    check_function_existance       shift and go to state 71
    push_id_operand                shift and go to state 128

state 112

    (12) statute -> condition .

    ID              reduce using rule 12 (statute -> condition .)
    IF              reduce using rule 12 (statute -> condition .)
    PRINT           reduce using rule 12 (statute -> condition .)
    WHILE           reduce using rule 12 (statute -> condition .)
    RETURN          reduce using rule 12 (statute -> condition .)
    RBRACE          reduce using rule 12 (statute -> condition .)


state 113

    (18) condition -> IF . LPAREN sexpression RPAREN do_condition_operation block else

    LPAREN          shift and go to state 129


state 114

    (9) blockprima -> statute . blockprima
    (9) blockprima -> . statute blockprima
    (10) blockprima -> . empty
    (11) statute -> . assignment
    (12) statute -> . condition
    (13) statute -> . write
    (14) statute -> . read
    (15) statute -> . cycle
    (16) statute -> . functioncall SEMICOLON
    (17) statute -> . return
    (109) empty -> .
    (34) assignment -> . ID push_id_operand array ASSIGN push_operator sexpression SEMICOLON
    (18) condition -> . IF LPAREN sexpression RPAREN do_condition_operation block else
    (104) write -> . PRINT LPAREN sexpression RPAREN SEMICOLON
    (105) read -> . ID push_id_operand array ASSIGN push_operator INPUT LPAREN RPAREN SEMICOLON
    (106) cycle -> . WHILE push_cycle_jump LPAREN sexpression RPAREN do_while_operation block
    (82) functioncall -> . ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments
    (98) return -> . RETURN sexpression SEMICOLON

    RBRACE          reduce using rule 109 (empty -> .)
    ID              shift and go to state 111
    IF              shift and go to state 113
    PRINT           shift and go to state 103
    WHILE           shift and go to state 102
    RETURN          shift and go to state 101

    blockprima                     shift and go to state 130
    write                          shift and go to state 105
    empty                          shift and go to state 107
    return                         shift and go to state 108
    read                           shift and go to state 109
    assignment                     shift and go to state 110
    condition                      shift and go to state 112
    cycle                          shift and go to state 106
    statute                        shift and go to state 114
    functioncall                   shift and go to state 115

state 115

    (16) statute -> functioncall . SEMICOLON

    SEMICOLON       shift and go to state 131


state 116

    (99) parameter -> type ID store_parameter array . parameterprima
    (101) parameterprima -> . COMMA type ID store_parameter parameterprima
    (102) parameterprima -> . empty
    (109) empty -> .

    COMMA           shift and go to state 132
    RPAREN          reduce using rule 109 (empty -> .)

    parameterprima                 shift and go to state 133
    empty                          shift and go to state 134

state 117

    (91) function -> FUNCTION functiontype ID store_function LPAREN parameter RPAREN vars add_func_quad_start . block end_process function
    (8) block -> . LBRACE blockprima RBRACE

    LBRACE          shift and go to state 89

    block                          shift and go to state 135

state 118

    (52) exp -> exp mathoperators1 push_operator term . do_math_operation1
    (57) term -> term . mathoperators2 push_operator factor do_math_operation2
    (56) do_math_operation1 -> .
    (59) mathoperators2 -> . TIMES
    (60) mathoperators2 -> . DIVIDE

    PLUS            reduce using rule 56 (do_math_operation1 -> .)
    MINUS           reduce using rule 56 (do_math_operation1 -> .)
    LESS            reduce using rule 56 (do_math_operation1 -> .)
    GREATER         reduce using rule 56 (do_math_operation1 -> .)
    EQUAL           reduce using rule 56 (do_math_operation1 -> .)
    NOTEQUAL        reduce using rule 56 (do_math_operation1 -> .)
    LESSOREQUAL     reduce using rule 56 (do_math_operation1 -> .)
    GREATEROREQUAL  reduce using rule 56 (do_math_operation1 -> .)
    AND             reduce using rule 56 (do_math_operation1 -> .)
    OR              reduce using rule 56 (do_math_operation1 -> .)
    RBRACKET        reduce using rule 56 (do_math_operation1 -> .)
    RPAREN          reduce using rule 56 (do_math_operation1 -> .)
    SEMICOLON       reduce using rule 56 (do_math_operation1 -> .)
    COMMA           reduce using rule 56 (do_math_operation1 -> .)
    TIMES           shift and go to state 74
    DIVIDE          shift and go to state 73

    do_math_operation1             shift and go to state 136
    mathoperators2                 shift and go to state 75

state 119

    (62) factor -> LPAREN push_false_bottom sexpression RPAREN . pop_false_bottom
    (65) pop_false_bottom -> .

    TIMES           reduce using rule 65 (pop_false_bottom -> .)
    DIVIDE          reduce using rule 65 (pop_false_bottom -> .)
    PLUS            reduce using rule 65 (pop_false_bottom -> .)
    MINUS           reduce using rule 65 (pop_false_bottom -> .)
    LESS            reduce using rule 65 (pop_false_bottom -> .)
    GREATER         reduce using rule 65 (pop_false_bottom -> .)
    EQUAL           reduce using rule 65 (pop_false_bottom -> .)
    NOTEQUAL        reduce using rule 65 (pop_false_bottom -> .)
    LESSOREQUAL     reduce using rule 65 (pop_false_bottom -> .)
    GREATEROREQUAL  reduce using rule 65 (pop_false_bottom -> .)
    AND             reduce using rule 65 (pop_false_bottom -> .)
    OR              reduce using rule 65 (pop_false_bottom -> .)
    RBRACKET        reduce using rule 65 (pop_false_bottom -> .)
    RPAREN          reduce using rule 65 (pop_false_bottom -> .)
    SEMICOLON       reduce using rule 65 (pop_false_bottom -> .)
    COMMA           reduce using rule 65 (pop_false_bottom -> .)

    pop_false_bottom               shift and go to state 137

state 120

    (82) functioncall -> ID check_function_existance LPAREN generate_era . funcargum RPAREN validate_arguments
    (86) funcargum -> . sexpression store_argument funcargumprima
    (87) funcargum -> . empty
    (37) sexpression -> . negation expression do_not_operation
    (109) empty -> .
    (38) negation -> . NOT push_operator
    (39) negation -> . empty

    RPAREN          reduce using rule 109 (empty -> .)
    LPAREN          reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FLOAT           reduce using rule 109 (empty -> .)
    INT             reduce using rule 109 (empty -> .)
    STRING          reduce using rule 109 (empty -> .)
    TRUE            reduce using rule 109 (empty -> .)
    FALSE           reduce using rule 109 (empty -> .)
    NOT             shift and go to state 38

    negation                       shift and go to state 36
    sexpression                    shift and go to state 138
    funcargum                      shift and go to state 139
    empty                          shift and go to state 140

state 121

    (72) array -> LBRACKET access_dimen_var . sexpression validate_index RBRACKET
    (37) sexpression -> . negation expression do_not_operation
    (38) negation -> . NOT push_operator
    (39) negation -> . empty
    (109) empty -> .

    NOT             shift and go to state 38
    LPAREN          reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FLOAT           reduce using rule 109 (empty -> .)
    INT             reduce using rule 109 (empty -> .)
    STRING          reduce using rule 109 (empty -> .)
    TRUE            reduce using rule 109 (empty -> .)
    FALSE           reduce using rule 109 (empty -> .)

    negation                       shift and go to state 36
    sexpression                    shift and go to state 141
    empty                          shift and go to state 39

state 122

    (57) term -> term mathoperators2 push_operator factor . do_math_operation2
    (61) do_math_operation2 -> .

    TIMES           reduce using rule 61 (do_math_operation2 -> .)
    DIVIDE          reduce using rule 61 (do_math_operation2 -> .)
    PLUS            reduce using rule 61 (do_math_operation2 -> .)
    MINUS           reduce using rule 61 (do_math_operation2 -> .)
    LESS            reduce using rule 61 (do_math_operation2 -> .)
    GREATER         reduce using rule 61 (do_math_operation2 -> .)
    EQUAL           reduce using rule 61 (do_math_operation2 -> .)
    NOTEQUAL        reduce using rule 61 (do_math_operation2 -> .)
    LESSOREQUAL     reduce using rule 61 (do_math_operation2 -> .)
    GREATEROREQUAL  reduce using rule 61 (do_math_operation2 -> .)
    AND             reduce using rule 61 (do_math_operation2 -> .)
    OR              reduce using rule 61 (do_math_operation2 -> .)
    RBRACKET        reduce using rule 61 (do_math_operation2 -> .)
    RPAREN          reduce using rule 61 (do_math_operation2 -> .)
    SEMICOLON       reduce using rule 61 (do_math_operation2 -> .)
    COMMA           reduce using rule 61 (do_math_operation2 -> .)

    do_math_operation2             shift and go to state 142

state 123

    (41) expression -> expression relationaloperators push_operator exp . do_relational_operation
    (52) exp -> exp . mathoperators1 push_operator term do_math_operation1
    (51) do_relational_operation -> .
    (54) mathoperators1 -> . PLUS
    (55) mathoperators1 -> . MINUS

    LESS            reduce using rule 51 (do_relational_operation -> .)
    GREATER         reduce using rule 51 (do_relational_operation -> .)
    EQUAL           reduce using rule 51 (do_relational_operation -> .)
    NOTEQUAL        reduce using rule 51 (do_relational_operation -> .)
    LESSOREQUAL     reduce using rule 51 (do_relational_operation -> .)
    GREATEROREQUAL  reduce using rule 51 (do_relational_operation -> .)
    AND             reduce using rule 51 (do_relational_operation -> .)
    OR              reduce using rule 51 (do_relational_operation -> .)
    RBRACKET        reduce using rule 51 (do_relational_operation -> .)
    RPAREN          reduce using rule 51 (do_relational_operation -> .)
    SEMICOLON       reduce using rule 51 (do_relational_operation -> .)
    COMMA           reduce using rule 51 (do_relational_operation -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 69

    do_relational_operation        shift and go to state 143
    mathoperators1                 shift and go to state 68

state 124

    (98) return -> RETURN sexpression . SEMICOLON

    SEMICOLON       shift and go to state 144


state 125

    (106) cycle -> WHILE push_cycle_jump . LPAREN sexpression RPAREN do_while_operation block

    LPAREN          shift and go to state 145


state 126

    (104) write -> PRINT LPAREN . sexpression RPAREN SEMICOLON
    (37) sexpression -> . negation expression do_not_operation
    (38) negation -> . NOT push_operator
    (39) negation -> . empty
    (109) empty -> .

    NOT             shift and go to state 38
    LPAREN          reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FLOAT           reduce using rule 109 (empty -> .)
    INT             reduce using rule 109 (empty -> .)
    STRING          reduce using rule 109 (empty -> .)
    TRUE            reduce using rule 109 (empty -> .)
    FALSE           reduce using rule 109 (empty -> .)

    negation                       shift and go to state 36
    sexpression                    shift and go to state 146
    empty                          shift and go to state 39

state 127

    (8) block -> LBRACE blockprima RBRACE .

    ID              reduce using rule 8 (block -> LBRACE blockprima RBRACE .)
    IF              reduce using rule 8 (block -> LBRACE blockprima RBRACE .)
    PRINT           reduce using rule 8 (block -> LBRACE blockprima RBRACE .)
    WHILE           reduce using rule 8 (block -> LBRACE blockprima RBRACE .)
    RETURN          reduce using rule 8 (block -> LBRACE blockprima RBRACE .)
    RBRACE          reduce using rule 8 (block -> LBRACE blockprima RBRACE .)
    ELSE            reduce using rule 8 (block -> LBRACE blockprima RBRACE .)
    $end            reduce using rule 8 (block -> LBRACE blockprima RBRACE .)
    FUNCTION        reduce using rule 8 (block -> LBRACE blockprima RBRACE .)
    INTTYPE         reduce using rule 8 (block -> LBRACE blockprima RBRACE .)


state 128

    (34) assignment -> ID push_id_operand . array ASSIGN push_operator sexpression SEMICOLON
    (105) read -> ID push_id_operand . array ASSIGN push_operator INPUT LPAREN RPAREN SEMICOLON
    (72) array -> . LBRACKET access_dimen_var sexpression validate_index RBRACKET
    (73) array -> . empty
    (109) empty -> .

    LBRACKET        shift and go to state 96
    ASSIGN          reduce using rule 109 (empty -> .)

    array                          shift and go to state 147
    empty                          shift and go to state 98

state 129

    (18) condition -> IF LPAREN . sexpression RPAREN do_condition_operation block else
    (37) sexpression -> . negation expression do_not_operation
    (38) negation -> . NOT push_operator
    (39) negation -> . empty
    (109) empty -> .

    NOT             shift and go to state 38
    LPAREN          reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FLOAT           reduce using rule 109 (empty -> .)
    INT             reduce using rule 109 (empty -> .)
    STRING          reduce using rule 109 (empty -> .)
    TRUE            reduce using rule 109 (empty -> .)
    FALSE           reduce using rule 109 (empty -> .)

    negation                       shift and go to state 36
    sexpression                    shift and go to state 148
    empty                          shift and go to state 39

state 130

    (9) blockprima -> statute blockprima .

    RBRACE          reduce using rule 9 (blockprima -> statute blockprima .)


state 131

    (16) statute -> functioncall SEMICOLON .

    ID              reduce using rule 16 (statute -> functioncall SEMICOLON .)
    IF              reduce using rule 16 (statute -> functioncall SEMICOLON .)
    PRINT           reduce using rule 16 (statute -> functioncall SEMICOLON .)
    WHILE           reduce using rule 16 (statute -> functioncall SEMICOLON .)
    RETURN          reduce using rule 16 (statute -> functioncall SEMICOLON .)
    RBRACE          reduce using rule 16 (statute -> functioncall SEMICOLON .)


state 132

    (101) parameterprima -> COMMA . type ID store_parameter parameterprima
    (30) type -> . INTTYPE
    (31) type -> . FLOATTYPE
    (32) type -> . STRINGTYPE
    (33) type -> . BOOLTYPE

    INTTYPE         shift and go to state 16
    FLOATTYPE       shift and go to state 15
    STRINGTYPE      shift and go to state 14
    BOOLTYPE        shift and go to state 13

    type                           shift and go to state 149

state 133

    (99) parameter -> type ID store_parameter array parameterprima .

    RPAREN          reduce using rule 99 (parameter -> type ID store_parameter array parameterprima .)


state 134

    (102) parameterprima -> empty .

    RPAREN          reduce using rule 102 (parameterprima -> empty .)


state 135

    (91) function -> FUNCTION functiontype ID store_function LPAREN parameter RPAREN vars add_func_quad_start block . end_process function
    (97) end_process -> .

    FUNCTION        reduce using rule 97 (end_process -> .)
    INTTYPE         reduce using rule 97 (end_process -> .)

    end_process                    shift and go to state 150

state 136

    (52) exp -> exp mathoperators1 push_operator term do_math_operation1 .

    PLUS            reduce using rule 52 (exp -> exp mathoperators1 push_operator term do_math_operation1 .)
    MINUS           reduce using rule 52 (exp -> exp mathoperators1 push_operator term do_math_operation1 .)
    LESS            reduce using rule 52 (exp -> exp mathoperators1 push_operator term do_math_operation1 .)
    GREATER         reduce using rule 52 (exp -> exp mathoperators1 push_operator term do_math_operation1 .)
    EQUAL           reduce using rule 52 (exp -> exp mathoperators1 push_operator term do_math_operation1 .)
    NOTEQUAL        reduce using rule 52 (exp -> exp mathoperators1 push_operator term do_math_operation1 .)
    LESSOREQUAL     reduce using rule 52 (exp -> exp mathoperators1 push_operator term do_math_operation1 .)
    GREATEROREQUAL  reduce using rule 52 (exp -> exp mathoperators1 push_operator term do_math_operation1 .)
    AND             reduce using rule 52 (exp -> exp mathoperators1 push_operator term do_math_operation1 .)
    OR              reduce using rule 52 (exp -> exp mathoperators1 push_operator term do_math_operation1 .)
    RBRACKET        reduce using rule 52 (exp -> exp mathoperators1 push_operator term do_math_operation1 .)
    RPAREN          reduce using rule 52 (exp -> exp mathoperators1 push_operator term do_math_operation1 .)
    SEMICOLON       reduce using rule 52 (exp -> exp mathoperators1 push_operator term do_math_operation1 .)
    COMMA           reduce using rule 52 (exp -> exp mathoperators1 push_operator term do_math_operation1 .)


state 137

    (62) factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .

    TIMES           reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)
    DIVIDE          reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)
    PLUS            reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)
    MINUS           reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)
    LESS            reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)
    GREATER         reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)
    EQUAL           reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)
    NOTEQUAL        reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)
    LESSOREQUAL     reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)
    GREATEROREQUAL  reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)
    AND             reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)
    OR              reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)
    RBRACKET        reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)
    RPAREN          reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)
    SEMICOLON       reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)
    COMMA           reduce using rule 62 (factor -> LPAREN push_false_bottom sexpression RPAREN pop_false_bottom .)


state 138

    (86) funcargum -> sexpression . store_argument funcargumprima
    (90) store_argument -> .

    COMMA           reduce using rule 90 (store_argument -> .)
    RPAREN          reduce using rule 90 (store_argument -> .)

    store_argument                 shift and go to state 151

state 139

    (82) functioncall -> ID check_function_existance LPAREN generate_era funcargum . RPAREN validate_arguments

    RPAREN          shift and go to state 152


state 140

    (87) funcargum -> empty .
    (39) negation -> empty .

    RPAREN          reduce using rule 87 (funcargum -> empty .)
    LPAREN          reduce using rule 39 (negation -> empty .)
    ID              reduce using rule 39 (negation -> empty .)
    FLOAT           reduce using rule 39 (negation -> empty .)
    INT             reduce using rule 39 (negation -> empty .)
    STRING          reduce using rule 39 (negation -> empty .)
    TRUE            reduce using rule 39 (negation -> empty .)
    FALSE           reduce using rule 39 (negation -> empty .)


state 141

    (72) array -> LBRACKET access_dimen_var sexpression . validate_index RBRACKET
    (74) validate_index -> .

    RBRACKET        reduce using rule 74 (validate_index -> .)

    validate_index                 shift and go to state 153

state 142

    (57) term -> term mathoperators2 push_operator factor do_math_operation2 .

    TIMES           reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)
    DIVIDE          reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)
    PLUS            reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)
    MINUS           reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)
    LESS            reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)
    GREATER         reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)
    EQUAL           reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)
    NOTEQUAL        reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)
    LESSOREQUAL     reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)
    GREATEROREQUAL  reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)
    AND             reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)
    OR              reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)
    RBRACKET        reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)
    RPAREN          reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)
    SEMICOLON       reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)
    COMMA           reduce using rule 57 (term -> term mathoperators2 push_operator factor do_math_operation2 .)


state 143

    (41) expression -> expression relationaloperators push_operator exp do_relational_operation .

    LESS            reduce using rule 41 (expression -> expression relationaloperators push_operator exp do_relational_operation .)
    GREATER         reduce using rule 41 (expression -> expression relationaloperators push_operator exp do_relational_operation .)
    EQUAL           reduce using rule 41 (expression -> expression relationaloperators push_operator exp do_relational_operation .)
    NOTEQUAL        reduce using rule 41 (expression -> expression relationaloperators push_operator exp do_relational_operation .)
    LESSOREQUAL     reduce using rule 41 (expression -> expression relationaloperators push_operator exp do_relational_operation .)
    GREATEROREQUAL  reduce using rule 41 (expression -> expression relationaloperators push_operator exp do_relational_operation .)
    AND             reduce using rule 41 (expression -> expression relationaloperators push_operator exp do_relational_operation .)
    OR              reduce using rule 41 (expression -> expression relationaloperators push_operator exp do_relational_operation .)
    RBRACKET        reduce using rule 41 (expression -> expression relationaloperators push_operator exp do_relational_operation .)
    RPAREN          reduce using rule 41 (expression -> expression relationaloperators push_operator exp do_relational_operation .)
    SEMICOLON       reduce using rule 41 (expression -> expression relationaloperators push_operator exp do_relational_operation .)
    COMMA           reduce using rule 41 (expression -> expression relationaloperators push_operator exp do_relational_operation .)


state 144

    (98) return -> RETURN sexpression SEMICOLON .

    ID              reduce using rule 98 (return -> RETURN sexpression SEMICOLON .)
    IF              reduce using rule 98 (return -> RETURN sexpression SEMICOLON .)
    PRINT           reduce using rule 98 (return -> RETURN sexpression SEMICOLON .)
    WHILE           reduce using rule 98 (return -> RETURN sexpression SEMICOLON .)
    RETURN          reduce using rule 98 (return -> RETURN sexpression SEMICOLON .)
    RBRACE          reduce using rule 98 (return -> RETURN sexpression SEMICOLON .)


state 145

    (106) cycle -> WHILE push_cycle_jump LPAREN . sexpression RPAREN do_while_operation block
    (37) sexpression -> . negation expression do_not_operation
    (38) negation -> . NOT push_operator
    (39) negation -> . empty
    (109) empty -> .

    NOT             shift and go to state 38
    LPAREN          reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FLOAT           reduce using rule 109 (empty -> .)
    INT             reduce using rule 109 (empty -> .)
    STRING          reduce using rule 109 (empty -> .)
    TRUE            reduce using rule 109 (empty -> .)
    FALSE           reduce using rule 109 (empty -> .)

    negation                       shift and go to state 36
    sexpression                    shift and go to state 154
    empty                          shift and go to state 39

state 146

    (104) write -> PRINT LPAREN sexpression . RPAREN SEMICOLON

    RPAREN          shift and go to state 155


state 147

    (34) assignment -> ID push_id_operand array . ASSIGN push_operator sexpression SEMICOLON
    (105) read -> ID push_id_operand array . ASSIGN push_operator INPUT LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 156


state 148

    (18) condition -> IF LPAREN sexpression . RPAREN do_condition_operation block else

    RPAREN          shift and go to state 157


state 149

    (101) parameterprima -> COMMA type . ID store_parameter parameterprima

    ID              shift and go to state 158


state 150

    (91) function -> FUNCTION functiontype ID store_function LPAREN parameter RPAREN vars add_func_quad_start block end_process . function
    (91) function -> . FUNCTION functiontype ID store_function LPAREN parameter RPAREN vars add_func_quad_start block end_process function
    (92) function -> . empty
    (109) empty -> .

    FUNCTION        shift and go to state 11
    INTTYPE         reduce using rule 109 (empty -> .)

    function                       shift and go to state 159
    empty                          shift and go to state 12

state 151

    (86) funcargum -> sexpression store_argument . funcargumprima
    (88) funcargumprima -> . COMMA sexpression store_argument funcargumprima
    (89) funcargumprima -> . empty
    (109) empty -> .

    COMMA           shift and go to state 161
    RPAREN          reduce using rule 109 (empty -> .)

    funcargumprima                 shift and go to state 160
    empty                          shift and go to state 162

state 152

    (82) functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN . validate_arguments
    (85) validate_arguments -> .

    TIMES           reduce using rule 85 (validate_arguments -> .)
    DIVIDE          reduce using rule 85 (validate_arguments -> .)
    PLUS            reduce using rule 85 (validate_arguments -> .)
    MINUS           reduce using rule 85 (validate_arguments -> .)
    LESS            reduce using rule 85 (validate_arguments -> .)
    GREATER         reduce using rule 85 (validate_arguments -> .)
    EQUAL           reduce using rule 85 (validate_arguments -> .)
    NOTEQUAL        reduce using rule 85 (validate_arguments -> .)
    LESSOREQUAL     reduce using rule 85 (validate_arguments -> .)
    GREATEROREQUAL  reduce using rule 85 (validate_arguments -> .)
    AND             reduce using rule 85 (validate_arguments -> .)
    OR              reduce using rule 85 (validate_arguments -> .)
    RBRACKET        reduce using rule 85 (validate_arguments -> .)
    RPAREN          reduce using rule 85 (validate_arguments -> .)
    SEMICOLON       reduce using rule 85 (validate_arguments -> .)
    COMMA           reduce using rule 85 (validate_arguments -> .)

    validate_arguments             shift and go to state 163

state 153

    (72) array -> LBRACKET access_dimen_var sexpression validate_index . RBRACKET

    RBRACKET        shift and go to state 164


state 154

    (106) cycle -> WHILE push_cycle_jump LPAREN sexpression . RPAREN do_while_operation block

    RPAREN          shift and go to state 165


state 155

    (104) write -> PRINT LPAREN sexpression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 166


state 156

    (34) assignment -> ID push_id_operand array ASSIGN . push_operator sexpression SEMICOLON
    (105) read -> ID push_id_operand array ASSIGN . push_operator INPUT LPAREN RPAREN SEMICOLON
    (36) push_operator -> .

    INPUT           reduce using rule 36 (push_operator -> .)
    NOT             reduce using rule 36 (push_operator -> .)
    LPAREN          reduce using rule 36 (push_operator -> .)
    ID              reduce using rule 36 (push_operator -> .)
    FLOAT           reduce using rule 36 (push_operator -> .)
    INT             reduce using rule 36 (push_operator -> .)
    STRING          reduce using rule 36 (push_operator -> .)
    TRUE            reduce using rule 36 (push_operator -> .)
    FALSE           reduce using rule 36 (push_operator -> .)

    push_operator                  shift and go to state 167

state 157

    (18) condition -> IF LPAREN sexpression RPAREN . do_condition_operation block else
    (19) do_condition_operation -> .

    LBRACE          reduce using rule 19 (do_condition_operation -> .)

    do_condition_operation         shift and go to state 168

state 158

    (101) parameterprima -> COMMA type ID . store_parameter parameterprima
    (103) store_parameter -> .

    COMMA           reduce using rule 103 (store_parameter -> .)
    RPAREN          reduce using rule 103 (store_parameter -> .)

    store_parameter                shift and go to state 169

state 159

    (91) function -> FUNCTION functiontype ID store_function LPAREN parameter RPAREN vars add_func_quad_start block end_process function .

    INTTYPE         reduce using rule 91 (function -> FUNCTION functiontype ID store_function LPAREN parameter RPAREN vars add_func_quad_start block end_process function .)


state 160

    (86) funcargum -> sexpression store_argument funcargumprima .

    RPAREN          reduce using rule 86 (funcargum -> sexpression store_argument funcargumprima .)


state 161

    (88) funcargumprima -> COMMA . sexpression store_argument funcargumprima
    (37) sexpression -> . negation expression do_not_operation
    (38) negation -> . NOT push_operator
    (39) negation -> . empty
    (109) empty -> .

    NOT             shift and go to state 38
    LPAREN          reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FLOAT           reduce using rule 109 (empty -> .)
    INT             reduce using rule 109 (empty -> .)
    STRING          reduce using rule 109 (empty -> .)
    TRUE            reduce using rule 109 (empty -> .)
    FALSE           reduce using rule 109 (empty -> .)

    negation                       shift and go to state 36
    sexpression                    shift and go to state 170
    empty                          shift and go to state 39

state 162

    (89) funcargumprima -> empty .

    RPAREN          reduce using rule 89 (funcargumprima -> empty .)


state 163

    (82) functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .

    TIMES           reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)
    DIVIDE          reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)
    PLUS            reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)
    MINUS           reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)
    LESS            reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)
    GREATER         reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)
    EQUAL           reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)
    NOTEQUAL        reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)
    LESSOREQUAL     reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)
    GREATEROREQUAL  reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)
    AND             reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)
    OR              reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)
    RBRACKET        reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)
    RPAREN          reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)
    SEMICOLON       reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)
    COMMA           reduce using rule 82 (functioncall -> ID check_function_existance LPAREN generate_era funcargum RPAREN validate_arguments .)


state 164

    (72) array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .

    COMMA           reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    RPAREN          reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    ASSIGN          reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    TIMES           reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    DIVIDE          reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    PLUS            reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    MINUS           reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    LESS            reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    GREATER         reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    EQUAL           reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    NOTEQUAL        reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    LESSOREQUAL     reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    GREATEROREQUAL  reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    AND             reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    OR              reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    RBRACKET        reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)
    SEMICOLON       reduce using rule 72 (array -> LBRACKET access_dimen_var sexpression validate_index RBRACKET .)


state 165

    (106) cycle -> WHILE push_cycle_jump LPAREN sexpression RPAREN . do_while_operation block
    (108) do_while_operation -> .

    LBRACE          reduce using rule 108 (do_while_operation -> .)

    do_while_operation             shift and go to state 171

state 166

    (104) write -> PRINT LPAREN sexpression RPAREN SEMICOLON .

    ID              reduce using rule 104 (write -> PRINT LPAREN sexpression RPAREN SEMICOLON .)
    IF              reduce using rule 104 (write -> PRINT LPAREN sexpression RPAREN SEMICOLON .)
    PRINT           reduce using rule 104 (write -> PRINT LPAREN sexpression RPAREN SEMICOLON .)
    WHILE           reduce using rule 104 (write -> PRINT LPAREN sexpression RPAREN SEMICOLON .)
    RETURN          reduce using rule 104 (write -> PRINT LPAREN sexpression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 104 (write -> PRINT LPAREN sexpression RPAREN SEMICOLON .)


state 167

    (34) assignment -> ID push_id_operand array ASSIGN push_operator . sexpression SEMICOLON
    (105) read -> ID push_id_operand array ASSIGN push_operator . INPUT LPAREN RPAREN SEMICOLON
    (37) sexpression -> . negation expression do_not_operation
    (38) negation -> . NOT push_operator
    (39) negation -> . empty
    (109) empty -> .

    INPUT           shift and go to state 173
    NOT             shift and go to state 38
    LPAREN          reduce using rule 109 (empty -> .)
    ID              reduce using rule 109 (empty -> .)
    FLOAT           reduce using rule 109 (empty -> .)
    INT             reduce using rule 109 (empty -> .)
    STRING          reduce using rule 109 (empty -> .)
    TRUE            reduce using rule 109 (empty -> .)
    FALSE           reduce using rule 109 (empty -> .)

    negation                       shift and go to state 36
    sexpression                    shift and go to state 172
    empty                          shift and go to state 39

state 168

    (18) condition -> IF LPAREN sexpression RPAREN do_condition_operation . block else
    (8) block -> . LBRACE blockprima RBRACE

    LBRACE          shift and go to state 89

    block                          shift and go to state 174

state 169

    (101) parameterprima -> COMMA type ID store_parameter . parameterprima
    (101) parameterprima -> . COMMA type ID store_parameter parameterprima
    (102) parameterprima -> . empty
    (109) empty -> .

    COMMA           shift and go to state 132
    RPAREN          reduce using rule 109 (empty -> .)

    parameterprima                 shift and go to state 175
    empty                          shift and go to state 134

state 170

    (88) funcargumprima -> COMMA sexpression . store_argument funcargumprima
    (90) store_argument -> .

    COMMA           reduce using rule 90 (store_argument -> .)
    RPAREN          reduce using rule 90 (store_argument -> .)

    store_argument                 shift and go to state 176

state 171

    (106) cycle -> WHILE push_cycle_jump LPAREN sexpression RPAREN do_while_operation . block
    (8) block -> . LBRACE blockprima RBRACE

    LBRACE          shift and go to state 89

    block                          shift and go to state 177

state 172

    (34) assignment -> ID push_id_operand array ASSIGN push_operator sexpression . SEMICOLON

    SEMICOLON       shift and go to state 178


state 173

    (105) read -> ID push_id_operand array ASSIGN push_operator INPUT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 179


state 174

    (18) condition -> IF LPAREN sexpression RPAREN do_condition_operation block . else
    (20) else -> . ELSE do_else_operation block
    (21) else -> . empty
    (109) empty -> .

    ELSE            shift and go to state 182
    ID              reduce using rule 109 (empty -> .)
    IF              reduce using rule 109 (empty -> .)
    PRINT           reduce using rule 109 (empty -> .)
    WHILE           reduce using rule 109 (empty -> .)
    RETURN          reduce using rule 109 (empty -> .)
    RBRACE          reduce using rule 109 (empty -> .)

    else                           shift and go to state 180
    empty                          shift and go to state 181

state 175

    (101) parameterprima -> COMMA type ID store_parameter parameterprima .

    RPAREN          reduce using rule 101 (parameterprima -> COMMA type ID store_parameter parameterprima .)


state 176

    (88) funcargumprima -> COMMA sexpression store_argument . funcargumprima
    (88) funcargumprima -> . COMMA sexpression store_argument funcargumprima
    (89) funcargumprima -> . empty
    (109) empty -> .

    COMMA           shift and go to state 161
    RPAREN          reduce using rule 109 (empty -> .)

    funcargumprima                 shift and go to state 183
    empty                          shift and go to state 162

state 177

    (106) cycle -> WHILE push_cycle_jump LPAREN sexpression RPAREN do_while_operation block .

    ID              reduce using rule 106 (cycle -> WHILE push_cycle_jump LPAREN sexpression RPAREN do_while_operation block .)
    IF              reduce using rule 106 (cycle -> WHILE push_cycle_jump LPAREN sexpression RPAREN do_while_operation block .)
    PRINT           reduce using rule 106 (cycle -> WHILE push_cycle_jump LPAREN sexpression RPAREN do_while_operation block .)
    WHILE           reduce using rule 106 (cycle -> WHILE push_cycle_jump LPAREN sexpression RPAREN do_while_operation block .)
    RETURN          reduce using rule 106 (cycle -> WHILE push_cycle_jump LPAREN sexpression RPAREN do_while_operation block .)
    RBRACE          reduce using rule 106 (cycle -> WHILE push_cycle_jump LPAREN sexpression RPAREN do_while_operation block .)


state 178

    (34) assignment -> ID push_id_operand array ASSIGN push_operator sexpression SEMICOLON .

    ID              reduce using rule 34 (assignment -> ID push_id_operand array ASSIGN push_operator sexpression SEMICOLON .)
    IF              reduce using rule 34 (assignment -> ID push_id_operand array ASSIGN push_operator sexpression SEMICOLON .)
    PRINT           reduce using rule 34 (assignment -> ID push_id_operand array ASSIGN push_operator sexpression SEMICOLON .)
    WHILE           reduce using rule 34 (assignment -> ID push_id_operand array ASSIGN push_operator sexpression SEMICOLON .)
    RETURN          reduce using rule 34 (assignment -> ID push_id_operand array ASSIGN push_operator sexpression SEMICOLON .)
    RBRACE          reduce using rule 34 (assignment -> ID push_id_operand array ASSIGN push_operator sexpression SEMICOLON .)


state 179

    (105) read -> ID push_id_operand array ASSIGN push_operator INPUT LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 184


state 180

    (18) condition -> IF LPAREN sexpression RPAREN do_condition_operation block else .

    ID              reduce using rule 18 (condition -> IF LPAREN sexpression RPAREN do_condition_operation block else .)
    IF              reduce using rule 18 (condition -> IF LPAREN sexpression RPAREN do_condition_operation block else .)
    PRINT           reduce using rule 18 (condition -> IF LPAREN sexpression RPAREN do_condition_operation block else .)
    WHILE           reduce using rule 18 (condition -> IF LPAREN sexpression RPAREN do_condition_operation block else .)
    RETURN          reduce using rule 18 (condition -> IF LPAREN sexpression RPAREN do_condition_operation block else .)
    RBRACE          reduce using rule 18 (condition -> IF LPAREN sexpression RPAREN do_condition_operation block else .)


state 181

    (21) else -> empty .

    ID              reduce using rule 21 (else -> empty .)
    IF              reduce using rule 21 (else -> empty .)
    PRINT           reduce using rule 21 (else -> empty .)
    WHILE           reduce using rule 21 (else -> empty .)
    RETURN          reduce using rule 21 (else -> empty .)
    RBRACE          reduce using rule 21 (else -> empty .)


state 182

    (20) else -> ELSE . do_else_operation block
    (22) do_else_operation -> .

    LBRACE          reduce using rule 22 (do_else_operation -> .)

    do_else_operation              shift and go to state 185

state 183

    (88) funcargumprima -> COMMA sexpression store_argument funcargumprima .

    RPAREN          reduce using rule 88 (funcargumprima -> COMMA sexpression store_argument funcargumprima .)


state 184

    (105) read -> ID push_id_operand array ASSIGN push_operator INPUT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 186


state 185

    (20) else -> ELSE do_else_operation . block
    (8) block -> . LBRACE blockprima RBRACE

    LBRACE          shift and go to state 89

    block                          shift and go to state 187

state 186

    (105) read -> ID push_id_operand array ASSIGN push_operator INPUT LPAREN RPAREN SEMICOLON .

    ID              reduce using rule 105 (read -> ID push_id_operand array ASSIGN push_operator INPUT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 105 (read -> ID push_id_operand array ASSIGN push_operator INPUT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 105 (read -> ID push_id_operand array ASSIGN push_operator INPUT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 105 (read -> ID push_id_operand array ASSIGN push_operator INPUT LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 105 (read -> ID push_id_operand array ASSIGN push_operator INPUT LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 105 (read -> ID push_id_operand array ASSIGN push_operator INPUT LPAREN RPAREN SEMICOLON .)


state 187

    (20) else -> ELSE do_else_operation block .

    ID              reduce using rule 20 (else -> ELSE do_else_operation block .)
    IF              reduce using rule 20 (else -> ELSE do_else_operation block .)
    PRINT           reduce using rule 20 (else -> ELSE do_else_operation block .)
    WHILE           reduce using rule 20 (else -> ELSE do_else_operation block .)
    RETURN          reduce using rule 20 (else -> ELSE do_else_operation block .)
    RBRACE          reduce using rule 20 (else -> ELSE do_else_operation block .)

